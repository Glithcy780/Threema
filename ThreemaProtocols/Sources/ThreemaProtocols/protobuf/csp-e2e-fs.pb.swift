// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: csp-e2e-fs.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// # Forward Security Subprotocol
//
// This protocol specifies forward security for end-to-end encrypted chat server
// messages. It is based on sessions established between two parties, where each
// session has a unique ID and is associated with ephemeral key material
// negotiated between the parties using a key exchange mechanism and a hash
// chain based key derivation.
//
// Each party is either an initiator or a responder in a given session. Once
// established, a session will be used bidirectionally.
//
// Content messages can take any other type that could normally be sent without
// Forward Security, and wrap the message contained within using a separate
// cryptographic layer that provides Forward Security.
//
// TODO(SE-221): Add a section that describes when this subprotocol is being
// triggered and to which messages it is being applied.
//
// ## Terminology
//
// - `CK`: Client Key (permanent secret key associated to the Threema ID)
// - `FS`: Forward Security
// - `SI`: Session Initiator
// - `SR`: Session Responder
// - `2DH`: Unidirectional forward security with two DH calculations
// - `4DH`: Bidirectional forward security with four DH calculations
// - `FSSK`: Forward Security Session Key (ephemeral key pair generated by both
//   sides for each session)
// - `2DHK`: 2DH key (current iteration)
// - `4DHK`: 4DH key (current iteration)
// - `XDHK`: 2DH or 4DH key (current iteration).
// - `XDHMK`: 2DH or 4DH message key (current iteration)
//
// ## Modes
//
// Note: This is an informational section. The concrete steps surrounding modes
// are described in the steps for the `Envelope`.
//
// A key negotiation normally needs active participation by both involved
// parties before any actual messages can be exchanged. This is not practical in
// a messaging app, as the other party may not be online at the time when the
// first message is sent.
//
// Thus, the protocol specifies two modes, called 2DH and 4DH which will be
// described briefly in the following sections.
//
// ### 2DH Mode
//
// 2DH mode can be used immediately, even in a new session, as it does not
// involve any additional key material from the responder (i.e. remote party).
// However, it only protects against a compromise of the initiator's permanent
// secret key, not of the responder's permanent secret key. It is still better
// than sending all messages without Forward Security until a bidirectional 4DH
// session has been negotiated.
//
// ### 4DH Mode
//
// A session enters 4DH mode when the initiator has processed the responder's
// `Accept` message and sent an `Encapsulated.Confirm` message back to the
// responder. At this point, both sides have the required key material to derive
// the 4DH root chain key from. Messages sent from this point on are secure even
// in the event of a future compromise of the permanent secret key of either
// party.
//
// ## Keys
//
// Each party uses two different asymmetric X25519 key pairs:
//
// - `CK`: Client Key, the permanent secret key associated to the user's Threema
//   ID.
// - `FSSK`: Forward Security Session Key, an ephemeral key pair for the FS
//   session.
//
// Each party also learns the remote's `FSSK.public` from the `Init` or `Accept`
// message. The remote's `CK.public` of the peer's Threema ID is assumed to be
// already known.
//
// ## Key Derivation
//
// The two parties maintain the following keys during a session:
//
// - Local 2DHK (initiator only)
// - Remote 2DHK (responder only)
// - Local 4DHK (both parties)
// - Remote 4DHK (both parties)
//
// For each key, the current iteration of the key and a counter (see below) must
// be stored.
//
// The initiator derives the initial keys as follows:
//
//     local-2DHK = BLAKE2b(
//       key=BLAKE2b(
//         out-length=64,
//         input=
//              X25519HSalsa20(<local.CK>.secret, <remote.CK>.public)
//           || X25519HSalsa20(<local.FSSK>.secret, <remote.CK>.public)
//       ),
//       salt='ke-2dh-<local-threema-id>',
//       personal='3ma-e2e',
//     )
//
//     local-4DHK = BLAKE2b(
//       key=BLAKE2b(
//         out-length=64,
//         input=
//              X25519HSalsa20(<local.CK>.secret, <remote.CK>.public)
//           || X25519HSalsa20(<local.FSSK>.secret, <remote.CK>.public)
//           || X25519HSalsa20(<local.CK>.secret, <remote.FSSK>.public)
//           || X25519HSalsa20(<local.FSSK>.secret, <remote.FSSK>.public)
//       ),
//       salt='ke-4dh-<local-threema-id>',
//       personal='3ma-e2e',
//     )
//
//     remote-4DHK = BLAKE2b(
//       key=BLAKE2b(
//         out-length=64,
//         input=
//              X25519HSalsa20(<local.CK>.secret, <remote.CK>.public)
//           || X25519HSalsa20(<local.FSSK>.secret, <remote.CK>.public)
//           || X25519HSalsa20(<local.CK>.secret, <remote.FSSK>.public)
//           || X25519HSalsa20(<local.FSSK>.secret, <remote.FSSK>.public)
//       ),
//       salt='ke-4dh-<remote-threema-id>',
//       personal='3ma-e2e',
//     )
//
// The responder calculates the initial keys as follows:
//
//     remote-2DHK = BLAKE2b(
//       key=BLAKE2b(
//         out-length=64,
//         input=
//              X25519HSalsa20(<local.CK>.secret, <remote.CK>.public)
//           || X25519HSalsa20(<local.CK>.secret, <remote.FSSK>.public)
//       ),
//       salt='ke-2dh-<remote-threema-id>',
//       personal='3ma-e2e',
//     )
//
//     local-4DHK = BLAKE2b(
//       key=BLAKE2b(
//         out-length=64,
//         input=
//              X25519HSalsa20(<local.CK>.secret, <remote.CK>.public)
//           || X25519HSalsa20(<local.CK>.secret, <remote.FSSK>.public)
//           || X25519HSalsa20(<local.FSSK>.secret, <remote.CK>.public)
//           || X25519HSalsa20(<local.FSSK>.secret, <remote.FSSK>.public)
//       ),
//       salt='ke-4dh-<local-threema-id>',
//       personal='3ma-e2e',
//     )
//
//     remote-4DHK = BLAKE2b(
//       key=BLAKE2b(
//         out-length=64,
//         input=
//              X25519HSalsa20(<local.CK>.secret, <remote.CK>.public)
//           || X25519HSalsa20(<local.CK>.secret, <remote.FSSK>.public)
//           || X25519HSalsa20(<local.FSSK>.secret, <remote.CK>.public)
//           || X25519HSalsa20(<local.FSSK>.secret, <remote.FSSK>.public)
//       ),
//       salt='ke-4dh-<remote-threema-id>',
//       personal='3ma-e2e',
//     )
//
// Each of the `*DHK` keys will be superseded after a message has been encrypted
// in the respective direction as follows:
//
//     XDHK' = BLAKE2b(
//       key=<local|remote>-XDHK,
//       salt='kdf-ck',
//       personal='3ma-e2e',
//     )
//
// However, actual messages are encrypted by:
//
//     XDHMK = BLAKE2b(
//       key=<local|remote>-XDHK,
//       salt='kdf-aek',
//       personal='3ma-e2e',
//     )
//
// So, for example, when an outgoing 4DH message is being sent, it will be
// encrypted by deriving `XDHMK` from `local-4DHK` and then `local-4DHK` will be
// replaced by applying `XDKH'` to `local-4DHK`.
//
// ### Key Counters
//
// Note: This is an informational section. The concrete processing steps
// required for keys and key counters are deeply integrated into the processing
// steps of the `Envelope`.
//
// Each local/remote 2DHK/4DHK is associated with a counter, which describes how
// many times the XDHK' has been applied since the initial key derivation.
// Whenever a new message has been sent in a session, the corresponding counter
// must be incremented and the key replaced by applying the XDHK' derivation on
// it. As this operation cannot be reversed, counter values cannot go back.
//
// To account for lost messages (e.g. when the recipient has been offline for an
// extended period of time or when a short-lived message such as
// `typing-indicator` or `call-offer` has been removed from the chat server),
// either party must be prepared to accept counters that have skipped a few
// values, and apply XDHK' as many times as is needed to reach the new counter
// value. To limit the CPU impact, the permissible counter delta is limited to
// 25'000.
//
// Note: A counter delta of 25'000 allows for roughly 100 hours of typing while
// the recipient is offline. Users who exceed that are considered insane and out
// of scope!
//
// ## Session States
//
// This section explains the various possible session states.
//
// Note: This is an informational section. The concrete state creation and
// transformation steps are deeply integrated into the processing steps of the
// `Envelope`.
//
// The _local_ session states are only valid for SI while the _remote_ session
// states are only valid for SR.
//
// A session is considered _bidirectional_ 4DH if the session state is
// `local-out-4dh-in-4dh` (`L44`) or `remote-in-4dh-out-4dh` (`R44`).
//
// ### `local-out-2dh-in-none` (`L20`)
//
// - An `Init` has been sent to remote.
// - Outgoing messages are protected with 2DH.
// - Incoming messages are not allowed by this state.
// - Once an `Accept` has been received for this session, we move into
//   `local-out-4dh-in-4dh` (`L44`) state.
//
// ### `local-out-4dh-in-4dh` (`L44`)
//
// - An `Accept` has been received for this session.
// - Outgoing and incoming messages are protected with 4DH.
//
// ### `remote-in-2dh-out-none` (`R20`)
//
// - An `Init` has been received and the session has been created. An `Accept`
//   is supposed to be sent with the next outgoing message to remote.
// - Incoming messages are protected with 2DH.
// - Outgoing messages are not allowed by this state.
// - Once the `Accept` has been sent, we move into `remote-in-2dh-out-4dh`
//   (`R24`).
//
// ### `remote-in-2dh-out-4dh` (`R24`)
//
// - An `Accept` has been sent to remote.
// - Incoming messages are protected with 2DH.
// - Outgoing messages are protected with 4DH.
// - Once a 4DH encrypted `Encapsulated` message has been received for this
//   session, we move into `remote-in-4dh-out-4dh` (`R44`).
//
// ### `remote-in-4dh-out-4dh` (`R44`)
//
// - An incoming 4DH protected `Encapsulated` message has been received for this
//   session.
// - Outgoing and incoming messages are protected with 4DH.
//
// ## Protocol Flow
//
// Note: This is an informational section. The concrete flows are deeply
// integrated into the incoming/outgoing message processing steps.
//
// ### Session Establishment
//
// An FS session negotiation is typically started when a user sends the first
// message to a remote Threema ID. The user assumes the role of SI, creates a
// new `L20` session by sending an `Init` message, followed by any number of
// `Encapsulated` messages in 2DH mode.
//
//     SI ------------- Init -------------> SR   [1]
//     SI ------ Encapsulated (2DH) ------> SR   [0..N]
//
// Note that `Encapsulated` messages in 2DH mode are limited to the minimum
// version that is announced in the `Init` because the initiator does not know
// yet which version is supported by the responder.
//
// SR will create a corresponding `R20` session. Once an outgoing message
// towards SI is being triggered by SR, it will send an `Accept` and move the
// session into `R24` state, followed by any number of `Encapsulated` messages
// in 4DH mode.
//
//     SI <----------- Accept ------------- SI   [1]
//     SI <----- Encapsulated (4DH) ------- SR   [1..N]
//
// When SI receives the `Accept`, it will move the session into `L44` state,
// followed by any number of `Encapsulated` messages in 4DH mode.
//
//     SI ------ Encapsulated (4DH) ------> SR   [0..N]
//
// With the first `Encapsulated` message received, SR will move the session into
// `R44` state.
//
// At this point, the session has been fully established as a _bidirectional_
// 4DH session and either side may send any number of `Encapsulated` messages in
// 4DH mode.
//
// At any point either party may `Terminate` a session, for example when the
// user is about to delete their account (or FS session information) and wants
// to notify the peer that the key material should be discarded.
//
// If any party receives a `Encapsulated` message that it cannot decrypt (e.g.
// due to having lost the FS key material), it eventually sends a `Reject`
// message to inform the other party that it can no longer use this particular
// FS session, and also tells it the ID of the message that could not be
// decrypted. The sender can then (after manual confirmation by the user)
// re-send the message in a new FS session.
//
// ## Handling Session Loss
//
// A party could lose FS sessions information, e.g. due to reinstallation or
// relocation of the app to a new device. FS sessions are not included in
// backups, as this would conflict with their ephemeralness. When a party
// receives a message that it cannot decrypt due to a missing session, it
// signals this to the other party using a `Reject` message.
//
// ## Race Conditions
//
// It is possible for both parties to create an FS session independently, before
// having received the other party's `Init`. In that case, both parties
// determinstically run a conflict resolve mechanism based on the session ID.
//
// Each party will proceed normally to ensure any messages sent while the race
// is ongoing will be received. When choosing a session for sending a new
// message and there is more than one _bidirectional_ 4DH session available for
// the desired peer, the one with the lowest session ID will be chosen and the
// other one removed. This will ensure that both parties will eventually start
// using the same session in both directions.
//
// ## Notifying the User
//
// To prevent undetected MITM attacks by a third party that has gained access to
// the permanent secret key of either party, the user will be informed whenever
// a new session is negotiated or a non-FS message has been received even though
// an FS session was available.
//
// ## Session Implementation
//
// Note: This is a normative section. The steps will imply that these rules are
// being applied!
//
// Session uniqueness is determined by the following triple:
//
// - the remote Threema ID,
// - a session ID.
//
// When looking up an FS session, this tuple must always be provided!
//
// An FS session has the following properties:
//
// - a remote Threema ID,
// - a session ID, and
// - a state and all necessary properties associated to that state.
//
// An FS session must be stored in a standalone storage and not as part of the
// contact because FS sessions can be created prior to the contact being
// created.
//
// When an FS session state _transitions_, _moves_ or _advances_, all keys that
// are no longer required must be erased securely.
//
// When an XDHK key iteration is being _replaced_, it must be erased securely.
//
// When an FS session is being _removed_ or _replaced_, it and all associated
// properties must be erased securely.
//
// When a contact is being removed, all associated FS sessions must be erased
// securely as well.
//
// ### State Properties
//
// The following properties, and **only** those, must be associated to the
// state.
//
// `L20` properties:
//
// - `version-range`: Supported version range as announced in the `Init` by
//   local (immutable)
// - `local-fssk`: Local FSSK (secret key, immutable)
// - `local-2dhk`: Current key state of the `local-2DHK` for outgoing messages
//   (using version `version-range.min`, immutable)
//
// `L44` properties:
//
// - `local-4dhv`: Current version used for outgoing messages (mutable)
// - `local-4dhk`: Current key state of the `local-4DHK` for outgoing messages
//   (mutable).
// - `remote-4dhv`: Current version used for incoming messages (mutable)
// - `remote-4dhk`: Current key state of the `remote-4DHK` for incoming messages
//   (mutable)
//
// `R20` properties:
//
// - `version-range`: Supported version range as announced in the `Init` by
//   remote (immutable)
// - `remote-fssk`: Remote FSSK (public key, immutable)
// - `remote-2dhk`: Current key state of the `remote-2DHK` for incoming messages
//   (using version `version-range.min`, mutable)
//
// `R24` properties:
//
// - `remote-2dhv`: Current version used for incoming messages (immutable)
// - `remote-2dhk`: Current key state of the `remote-2DHK` for incoming messages
//   still in flight (mutable).
// - `local-4dhv`: Current version used for outgoing messages (mutable)
// - `local-4dhk`: Current key state of the `local-4DHK` for outgoing messages
//   (mutable).
// - `remote-4dhv`: Version used for incoming messages in `R44` state (immutable)
// - `remote-4dhk`: Key for incoming messages in `R44` state (immutable).
//
// `R44` properties:
//
// - `local-4dhv`: Current version used for outgoing messages (mutable).
// - `local-4dhk`: Current key state of the `local-4DHK` for outgoing messages
//   (mutable).
// - `remote-4dhv`: Current version used for incoming messages (mutable).
// - `remote-4dhk`: Current key state of the `remote-4DHK` for incoming messages
//   (mutable).
//
// ### Key State
//
// A key state contains a key iteration, i.e. a local or remote `XDHK`, and the
// associated counter.
//
// The key state is bound to a specific direction (i.e. _local_ for outgoing
// messages or _remote_ for incoming messages).
//
// The following steps are defined as the _XDHK Incoming Advance Steps_:
//
// 1. Let `target-counter` be the targeted `XDHK` key counter.
// 2. Let `xdhk` be the current `XDHK` iteration of the state.
// 3. Let `distance` be the counter distance between the counter associated to
//    `xdhk` and `target-counter`.
// 4. If `distance` is negative or if `distance` is greater than `1000`, log a
//    warning and return undefined.
// 5. Loop `distance` times:
//    1. Set `xdhk` to the output of XDHK' applied to `xdhk`.
// 6. Return the tuple of `xdhk` and a context handle that if run, runs the
//    _XDHK Replace Steps_ with `xdhk`.
//
// The following steps are defined as the _XDHK Replace Steps_:
//
// 1. Let `xdhk` be the `XDHK` that has just been used (e.g. most likely because
//    an incoming message has been processed).
// 2. Apply XDHK' to `xdhk` and replace the current `XDHK` iteration of the
//    state with the result of that derivation.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// A forward security version.
///
/// Note: The most significant byte is the major version and the least
/// significant byte is the minor version.
///
/// IMPORTANT: Don't remove any versions. Apps may serialize and deserialize this
/// enum into the database.
public enum CspE2eFs_Version: SwiftProtobuf.Enum {
  public typealias RawValue = Int

  /// The version is unspecified.
  case unspecified // = 0

  /// V1.0
  ///
  /// - The initial FS release with some backwards compatible adjustments.
  /// - Encapsulates only the following E2E messages:
  ///   - [`text`](ref:e2e.text)
  ///   - [`location`](ref:e2e.location)
  ///   - [`file`](ref:e2e.file)
  ///   - [`poll-setup`](ref:e2e.poll-setup)
  ///   - [`poll-vote`](ref:e2e.poll-vote)
  case v10 // = 256

  /// V1.1
  ///
  /// - Builds on V1.0 with backwards compatibility.
  /// - If the remote side announced support for V1.1, all 1:1 E2E messages will
  ///   be encapsulated.
  case v11 // = 257
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 256: self = .v10
    case 257: self = .v11
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .v10: return 256
    case .v11: return 257
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension CspE2eFs_Version: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [CspE2eFs_Version] = [
    .unspecified,
    .v10,
    .v11,
  ]
}

#endif  // swift(>=4.2)

/// Forward security version range.
public struct CspE2eFs_VersionRange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Minimum supported version.
  ///
  /// Note: This is the version that will be applied to 2DH message of the
  /// sender.
  public var min: UInt32 = 0

  /// Maximum supported version.
  public var max: UInt32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A forward security envelope associated to an FS session, containing session
/// signalling or an `Encapsulated` message.
public struct CspE2eFs_Envelope {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Forward security session ID, 16 bytes
  public var sessionID: Data = Data()

  public var content: CspE2eFs_Envelope.OneOf_Content? = nil

  public var init_p: CspE2eFs_Init {
    get {
      if case .init_p(let v)? = content {return v}
      return CspE2eFs_Init()
    }
    set {content = .init_p(newValue)}
  }

  public var accept: CspE2eFs_Accept {
    get {
      if case .accept(let v)? = content {return v}
      return CspE2eFs_Accept()
    }
    set {content = .accept(newValue)}
  }

  public var reject: CspE2eFs_Reject {
    get {
      if case .reject(let v)? = content {return v}
      return CspE2eFs_Reject()
    }
    set {content = .reject(newValue)}
  }

  public var terminate: CspE2eFs_Terminate {
    get {
      if case .terminate(let v)? = content {return v}
      return CspE2eFs_Terminate()
    }
    set {content = .terminate(newValue)}
  }

  public var encapsulated: CspE2eFs_Encapsulated {
    get {
      if case .encapsulated(let v)? = content {return v}
      return CspE2eFs_Encapsulated()
    }
    set {content = .encapsulated(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Content: Equatable {
    case init_p(CspE2eFs_Init)
    case accept(CspE2eFs_Accept)
    case reject(CspE2eFs_Reject)
    case terminate(CspE2eFs_Terminate)
    case encapsulated(CspE2eFs_Encapsulated)

  #if !swift(>=4.1)
    public static func ==(lhs: CspE2eFs_Envelope.OneOf_Content, rhs: CspE2eFs_Envelope.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.init_p, .init_p): return {
        guard case .init_p(let l) = lhs, case .init_p(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accept, .accept): return {
        guard case .accept(let l) = lhs, case .accept(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reject, .reject): return {
        guard case .reject(let l) = lhs, case .reject(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.terminate, .terminate): return {
        guard case .terminate(let l) = lhs, case .terminate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.encapsulated, .encapsulated): return {
        guard case .encapsulated(let l) = lhs, case .encapsulated(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  public init() {}
}

/// Initialises a new session.
///
/// When receiving this variant:
///
/// 1. [...]
/// 2. If the `supported_version` range does not include a supported version,
///    log a warning, discard the message and abort these steps.
/// 3. Ensure that `fssk` contains a valid Curve25519 public key, otherwise log
///    a warning, discard the message and abort these steps.
/// 4. [...]
public struct CspE2eFs_Init {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The version range supported by the initiator.
  ///
  /// If not provided, assume V1.0 (`0x0100`) for both `min` and `max`.
  public var supportedVersion: CspE2eFs_VersionRange {
    get {return _supportedVersion ?? CspE2eFs_VersionRange()}
    set {_supportedVersion = newValue}
  }
  /// Returns true if `supportedVersion` has been explicitly set.
  public var hasSupportedVersion: Bool {return self._supportedVersion != nil}
  /// Clears the value of `supportedVersion`. Subsequent reads from it will return its default value.
  public mutating func clearSupportedVersion() {self._supportedVersion = nil}

  /// Ephemeral X25519 public key.
  public var fssk: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _supportedVersion: CspE2eFs_VersionRange? = nil
}

/// Accepts a session.
///
/// When receiving this variant:
///
/// 1. [...]
/// 2. If the `supported_version` range does not include a supported version,
///    log a warning, discard the message and abort these steps.
/// 3. Ensure that `fssk` contains a valid Curve25519 public key, otherwise log
///    a warning, discard the message and abort these steps.
/// 4. [...]
public struct CspE2eFs_Accept {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The version range supported by the responder.
  ///
  /// If not provided, assume V1.0 (`0x0100`) for both `min` and `max`.
  public var supportedVersion: CspE2eFs_VersionRange {
    get {return _supportedVersion ?? CspE2eFs_VersionRange()}
    set {_supportedVersion = newValue}
  }
  /// Returns true if `supportedVersion` has been explicitly set.
  public var hasSupportedVersion: Bool {return self._supportedVersion != nil}
  /// Clears the value of `supportedVersion`. Subsequent reads from it will return its default value.
  public mutating func clearSupportedVersion() {self._supportedVersion = nil}

  /// Ephemeral X25519 public key.
  public var fssk: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _supportedVersion: CspE2eFs_VersionRange? = nil
}

/// Sent when receiving a `Encapsulated` message that cannot be decrypted (e.g.
/// because the recipient has lost the session information).
///
/// The peer should discard the FS session and start a new one, if possible.
public struct CspE2eFs_Reject {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Message ID of the `Encapsulated` message that could not be decrypted and
  /// that should be sent again in a new session or without a session.
  public var rejectedEncapsulatedMessageID: UInt64 = 0

  public var cause: CspE2eFs_Reject.Cause = .stateMismatch

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Cause for the reject.
  public enum Cause: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// General state mismatch. Explicitly includes the following cases:
    ///
    /// - The message could not be decrypted.
    /// - The DH type of the message does not match the expected DH type.
    /// - An unexpected (major) version has been used.
    case stateMismatch // = 0

    /// No session could be found matching the given Session ID.
    case unknownSession // = 1

    /// The active local feature set does not include support for forward
    /// security.
    case disabledByLocal // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .stateMismatch
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .stateMismatch
      case 1: self = .unknownSession
      case 2: self = .disabledByLocal
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .stateMismatch: return 0
      case .unknownSession: return 1
      case .disabledByLocal: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension CspE2eFs_Reject.Cause: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [CspE2eFs_Reject.Cause] = [
    .stateMismatch,
    .unknownSession,
    .disabledByLocal,
  ]
}

#endif  // swift(>=4.2)

/// Signals that the sender will not send any further `Encapsulated` messages in
/// this session. The recipient should discard all key material related to this
/// session.
public struct CspE2eFs_Terminate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var cause: CspE2eFs_Terminate.Cause = .unknownSession

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Cause for termination.
  public enum Cause: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// No session could be found matching the given Session ID.
    case unknownSession // = 0

    /// The session is being reset
    case reset // = 1

    /// The active local feature set does not include support for forward
    /// security.
    case disabledByLocal // = 2

    /// The remote feature set (fetched from the Directory) does not indicate
    /// support for forward security.
    case disabledByRemote // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownSession
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownSession
      case 1: self = .reset
      case 2: self = .disabledByLocal
      case 3: self = .disabledByRemote
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownSession: return 0
      case .reset: return 1
      case .disabledByLocal: return 2
      case .disabledByRemote: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension CspE2eFs_Terminate.Cause: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [CspE2eFs_Terminate.Cause] = [
    .unknownSession,
    .reset,
    .disabledByLocal,
    .disabledByRemote,
  ]
}

#endif  // swift(>=4.2)

/// A forward security encapsulated CSP E2EE message or a control message.
///
/// When receiving this variant:
///
/// 1. [...]
/// 2. If `offered_version` is `0`, set it to V1.0.
/// 3. If `applied_version` is `0`, set it to `offered_version`.
/// 4. If `applied_version` is > `offered_version`, `Reject` the message with a
///    `STATE_MISMATCH`, terminate the session and abort these steps.
/// 5. Let `state` be the current session state.
/// 6. If `dh_type` is `TWODH`:
///    1. If `state` is not `R20` or `R24`, `Reject` the message with a
///       `STATE_MISMATCH`, terminate the session and abort these steps.
///    2. If `state` is `R20`, let `expected-version` be
///       `state.version-range.min`.
///    3. If `state` is `R24`, let `expected-version` be `state.remote-2dhv`.
///    4. If `offered_version` and `applied_version` are not equal to
///       `expected-version`, `Reject` the message with a `STATE_MISMATCH`,
///       terminate the session and abort these steps.
/// 7. If `dh_type` is `FOURDH`:
///    1. If `state` is not `L44`, `R44` or `R24`, `Reject` the message with a
///       `STATE_MISMATCH`, terminate the session and abort these steps.
///    2. Let `pending-versions` be a set of local and remote versions to be
///       filled by the following steps.
///    3. If `offered_version` has a different major version, or is lower than
///       `state.local-4dhv`, `Reject` the message with a `STATE_MISMATCH`,
///       terminate the session and abort these steps.
///    4. If `offered_version` has a higher minor version than
///       `state.local-4dhv`, set `pending-versions.local-4dhv` to the maximum
///       commonly supported version with `offered_version`.
///    5. If `applied_version` has a different major version, or is lower than
///       `state.remote-4dhv`, or is not a supported version, `Reject` the
///       message with a `STATE_MISMATCH`, terminate the session and abort these
///       steps.
///    6. If `applied_version` has a higher minor version than
///       `state.remote-4dhv`, set `pending-versions.remote-4dhv` to
///       `applied_version`.
/// 8. [...]
public struct CspE2eFs_Encapsulated {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var dhType: CspE2eFs_Encapsulated.DHType = .twodh

  /// A monotonically increasing counter, starting at 1 for the first 2DH or 4DH
  /// `Encapsulated` message sent in this session, and incrementing by 1 for each
  /// successive `Encapsulated` message.
  ///
  /// - Counters for 2DH and 4DH are separate, as they are based on different
  ///   root keys.
  /// - Counters for each direction are separate.
  /// - Can be used by the recipient as a hint of how many times to
  ///   rotate/ratchet the KDF, in case an intermediate `Encapsulated` message
  ///   went missing.
  public var counter: UInt64 = 0

  /// The major negotiated version with the _offered_ minor version.
  public var offeredVersion: UInt32 = 0

  /// The major negotiated version with the _applied_ minor version.
  public var appliedVersion: UInt32 = 0

  /// A message as defined by `e2e.container` (but **without** PKCS#7 padding),
  /// encrypted by:
  ///
  /// ```text
  /// XSalsa20-Poly1305(
  ///   key=XDHMK,
  ///   nonce=00..00,
  ///   data=<e2e.container>,
  /// )
  /// ```
  public var encryptedInner: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Encryption scheme applied to the encapsulated message.
  public enum DHType: SwiftProtobuf.Enum {
    public typealias RawValue = Int

    /// The message is encrypted with the 2DH encryption scheme.
    case twodh // = 0

    /// The message is encrypted with the 4DH encryption scheme.
    case fourdh // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .twodh
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .twodh
      case 1: self = .fourdh
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .twodh: return 0
      case .fourdh: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension CspE2eFs_Encapsulated.DHType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [CspE2eFs_Encapsulated.DHType] = [
    .twodh,
    .fourdh,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension CspE2eFs_Version: @unchecked Sendable {}
extension CspE2eFs_VersionRange: @unchecked Sendable {}
extension CspE2eFs_Envelope: @unchecked Sendable {}
extension CspE2eFs_Envelope.OneOf_Content: @unchecked Sendable {}
extension CspE2eFs_Init: @unchecked Sendable {}
extension CspE2eFs_Accept: @unchecked Sendable {}
extension CspE2eFs_Reject: @unchecked Sendable {}
extension CspE2eFs_Reject.Cause: @unchecked Sendable {}
extension CspE2eFs_Terminate: @unchecked Sendable {}
extension CspE2eFs_Terminate.Cause: @unchecked Sendable {}
extension CspE2eFs_Encapsulated: @unchecked Sendable {}
extension CspE2eFs_Encapsulated.DHType: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "csp_e2e_fs"

extension CspE2eFs_Version: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    256: .same(proto: "V1_0"),
    257: .same(proto: "V1_1"),
  ]
}

extension CspE2eFs_VersionRange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".VersionRange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "min"),
    2: .same(proto: "max"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.min) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.max) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.min != 0 {
      try visitor.visitSingularUInt32Field(value: self.min, fieldNumber: 1)
    }
    if self.max != 0 {
      try visitor.visitSingularUInt32Field(value: self.max, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CspE2eFs_VersionRange, rhs: CspE2eFs_VersionRange) -> Bool {
    if lhs.min != rhs.min {return false}
    if lhs.max != rhs.max {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CspE2eFs_Envelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Envelope"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
    2: .same(proto: "init"),
    3: .same(proto: "accept"),
    4: .same(proto: "reject"),
    5: .same(proto: "terminate"),
    6: .same(proto: "encapsulated"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.sessionID) }()
      case 2: try {
        var v: CspE2eFs_Init?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .init_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .init_p(v)
        }
      }()
      case 3: try {
        var v: CspE2eFs_Accept?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .accept(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .accept(v)
        }
      }()
      case 4: try {
        var v: CspE2eFs_Reject?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .reject(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .reject(v)
        }
      }()
      case 5: try {
        var v: CspE2eFs_Terminate?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .terminate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .terminate(v)
        }
      }()
      case 6: try {
        var v: CspE2eFs_Encapsulated?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .encapsulated(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .encapsulated(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.sessionID.isEmpty {
      try visitor.visitSingularBytesField(value: self.sessionID, fieldNumber: 1)
    }
    switch self.content {
    case .init_p?: try {
      guard case .init_p(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .accept?: try {
      guard case .accept(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .reject?: try {
      guard case .reject(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .terminate?: try {
      guard case .terminate(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .encapsulated?: try {
      guard case .encapsulated(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CspE2eFs_Envelope, rhs: CspE2eFs_Envelope) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CspE2eFs_Init: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Init"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "supported_version"),
    1: .same(proto: "fssk"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.fssk) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._supportedVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.fssk.isEmpty {
      try visitor.visitSingularBytesField(value: self.fssk, fieldNumber: 1)
    }
    try { if let v = self._supportedVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CspE2eFs_Init, rhs: CspE2eFs_Init) -> Bool {
    if lhs._supportedVersion != rhs._supportedVersion {return false}
    if lhs.fssk != rhs.fssk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CspE2eFs_Accept: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Accept"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "supported_version"),
    1: .same(proto: "fssk"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.fssk) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._supportedVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.fssk.isEmpty {
      try visitor.visitSingularBytesField(value: self.fssk, fieldNumber: 1)
    }
    try { if let v = self._supportedVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CspE2eFs_Accept, rhs: CspE2eFs_Accept) -> Bool {
    if lhs._supportedVersion != rhs._supportedVersion {return false}
    if lhs.fssk != rhs.fssk {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CspE2eFs_Reject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Reject"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rejected_encapsulated_message_id"),
    2: .same(proto: "cause"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.rejectedEncapsulatedMessageID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.cause) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rejectedEncapsulatedMessageID != 0 {
      try visitor.visitSingularFixed64Field(value: self.rejectedEncapsulatedMessageID, fieldNumber: 1)
    }
    if self.cause != .stateMismatch {
      try visitor.visitSingularEnumField(value: self.cause, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CspE2eFs_Reject, rhs: CspE2eFs_Reject) -> Bool {
    if lhs.rejectedEncapsulatedMessageID != rhs.rejectedEncapsulatedMessageID {return false}
    if lhs.cause != rhs.cause {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CspE2eFs_Reject.Cause: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_MISMATCH"),
    1: .same(proto: "UNKNOWN_SESSION"),
    2: .same(proto: "DISABLED_BY_LOCAL"),
  ]
}

extension CspE2eFs_Terminate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Terminate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cause"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.cause) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.cause != .unknownSession {
      try visitor.visitSingularEnumField(value: self.cause, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CspE2eFs_Terminate, rhs: CspE2eFs_Terminate) -> Bool {
    if lhs.cause != rhs.cause {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CspE2eFs_Terminate.Cause: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_SESSION"),
    1: .same(proto: "RESET"),
    2: .same(proto: "DISABLED_BY_LOCAL"),
    3: .same(proto: "DISABLED_BY_REMOTE"),
  ]
}

extension CspE2eFs_Encapsulated: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Encapsulated"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dh_type"),
    2: .same(proto: "counter"),
    4: .standard(proto: "offered_version"),
    5: .standard(proto: "applied_version"),
    3: .standard(proto: "encrypted_inner"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.dhType) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.counter) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.encryptedInner) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.offeredVersion) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.appliedVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dhType != .twodh {
      try visitor.visitSingularEnumField(value: self.dhType, fieldNumber: 1)
    }
    if self.counter != 0 {
      try visitor.visitSingularUInt64Field(value: self.counter, fieldNumber: 2)
    }
    if !self.encryptedInner.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedInner, fieldNumber: 3)
    }
    if self.offeredVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.offeredVersion, fieldNumber: 4)
    }
    if self.appliedVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.appliedVersion, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CspE2eFs_Encapsulated, rhs: CspE2eFs_Encapsulated) -> Bool {
    if lhs.dhType != rhs.dhType {return false}
    if lhs.counter != rhs.counter {return false}
    if lhs.offeredVersion != rhs.offeredVersion {return false}
    if lhs.appliedVersion != rhs.appliedVersion {return false}
    if lhs.encryptedInner != rhs.encryptedInner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CspE2eFs_Encapsulated.DHType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TWODH"),
    1: .same(proto: "FOURDH"),
  ]
}
