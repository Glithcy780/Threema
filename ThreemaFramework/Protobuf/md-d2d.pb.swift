// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: md-d2d.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// ## Device to Device Protocol
//
// ### General Information
//
// Encryption format: 24 byte nonce prepended, followed by an NaCl box.
//
// All strings are UTF-8 encoded.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Message type as defined by the Chat Server Protocol.
enum D2d_MessageType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Invalid message type
  case invalid // = 0

  /// Text message
  case text // = 1

  /// Deprecated image message
  case deprecatedImage // = 2

  /// Location message
  case location // = 16

  /// Deprecated audio message
  case deprecatedAudio // = 20

  /// Deprecated video message
  case deprecatedVideo // = 19

  /// File message
  case file // = 23

  /// Create or finalise a poll
  case pollSetup // = 21

  /// Cast a vote on a poll
  case pollVote // = 22

  /// Call offer
  case callOffer // = 96

  /// Call answer
  case callAnswer // = 97

  /// Call ICE Candidate
  case callIceCandidate // = 98

  /// Call hangup
  case callHangup // = 99

  /// Call ringing
  case callRinging // = 100

  /// Delivery receipt
  case deliveryReceipt // = 128

  /// Typing indicator
  case typingIndicator // = 144

  /// Set profile picture of a contact
  case contactSetProfilePicture // = 24

  /// Delete profile picture of a contact
  case contactDeleteProfilePicture // = 25

  /// Request profile picture of a contact
  case contactRequestProfilePicture // = 26

  /// Announce a group's setup
  case groupSetup // = 74

  /// Rename a group
  case groupRename // = 75

  /// Leave a group
  case groupLeave // = 76

  /// Set a group's profile picture
  case groupSetProfilePicture // = 80

  /// Delete a group's profile picture
  case groupDeleteProfilePicture // = 84

  /// Request group synchronisation
  case groupRequestSync // = 81

  /// Group text message
  case groupText // = 65

  /// Group location message
  case groupLocation // = 66

  /// Group image message
  case groupImage // = 67

  /// Group audio message
  case groupAudio // = 69

  /// Group video message
  case groupVideo // = 68

  /// Group file message
  case groupFile // = 70

  /// Create or finalise a group poll
  case groupPollSetup // = 82

  /// Cast a vote on a group poll
  case groupPollVote // = 83
  case UNRECOGNIZED(Int)

  init() {
    self = .invalid
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .invalid
    case 1: self = .text
    case 2: self = .deprecatedImage
    case 16: self = .location
    case 19: self = .deprecatedVideo
    case 20: self = .deprecatedAudio
    case 21: self = .pollSetup
    case 22: self = .pollVote
    case 23: self = .file
    case 24: self = .contactSetProfilePicture
    case 25: self = .contactDeleteProfilePicture
    case 26: self = .contactRequestProfilePicture
    case 65: self = .groupText
    case 66: self = .groupLocation
    case 67: self = .groupImage
    case 68: self = .groupVideo
    case 69: self = .groupAudio
    case 70: self = .groupFile
    case 74: self = .groupSetup
    case 75: self = .groupRename
    case 76: self = .groupLeave
    case 80: self = .groupSetProfilePicture
    case 81: self = .groupRequestSync
    case 82: self = .groupPollSetup
    case 83: self = .groupPollVote
    case 84: self = .groupDeleteProfilePicture
    case 96: self = .callOffer
    case 97: self = .callAnswer
    case 98: self = .callIceCandidate
    case 99: self = .callHangup
    case 100: self = .callRinging
    case 128: self = .deliveryReceipt
    case 144: self = .typingIndicator
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .invalid: return 0
    case .text: return 1
    case .deprecatedImage: return 2
    case .location: return 16
    case .deprecatedVideo: return 19
    case .deprecatedAudio: return 20
    case .pollSetup: return 21
    case .pollVote: return 22
    case .file: return 23
    case .contactSetProfilePicture: return 24
    case .contactDeleteProfilePicture: return 25
    case .contactRequestProfilePicture: return 26
    case .groupText: return 65
    case .groupLocation: return 66
    case .groupImage: return 67
    case .groupVideo: return 68
    case .groupAudio: return 69
    case .groupFile: return 70
    case .groupSetup: return 74
    case .groupRename: return 75
    case .groupLeave: return 76
    case .groupSetProfilePicture: return 80
    case .groupRequestSync: return 81
    case .groupPollSetup: return 82
    case .groupPollVote: return 83
    case .groupDeleteProfilePicture: return 84
    case .callOffer: return 96
    case .callAnswer: return 97
    case .callIceCandidate: return 98
    case .callHangup: return 99
    case .callRinging: return 100
    case .deliveryReceipt: return 128
    case .typingIndicator: return 144
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension D2d_MessageType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [D2d_MessageType] = [
    .invalid,
    .text,
    .deprecatedImage,
    .location,
    .deprecatedAudio,
    .deprecatedVideo,
    .file,
    .pollSetup,
    .pollVote,
    .callOffer,
    .callAnswer,
    .callIceCandidate,
    .callHangup,
    .callRinging,
    .deliveryReceipt,
    .typingIndicator,
    .contactSetProfilePicture,
    .contactDeleteProfilePicture,
    .contactRequestProfilePicture,
    .groupSetup,
    .groupRename,
    .groupLeave,
    .groupSetProfilePicture,
    .groupDeleteProfilePicture,
    .groupRequestSync,
    .groupText,
    .groupLocation,
    .groupImage,
    .groupAudio,
    .groupVideo,
    .groupFile,
    .groupPollSetup,
    .groupPollVote,
  ]
}

#endif  // swift(>=4.2)

/// Data shared across all devices and transmitted during the handshake.
struct D2d_SharedDeviceData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Random amount of padding, ignored by the receiver
  var padding: Data = Data()

  /// Current lowest protocol version that must be supported by all devices
  var version: UInt32 = 0

  /// MDM parameters to be applied on all devices
  var mdmParameters: Sync_MdmParameters {
    get {return _mdmParameters ?? Sync_MdmParameters()}
    set {_mdmParameters = newValue}
  }
  /// Returns true if `mdmParameters` has been explicitly set.
  var hasMdmParameters: Bool {return self._mdmParameters != nil}
  /// Clears the value of `mdmParameters`. Subsequent reads from it will return its default value.
  mutating func clearMdmParameters() {self._mdmParameters = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mdmParameters: Sync_MdmParameters? = nil
}

/// Metadata about a device, determined by the device itself.
struct D2d_DeviceInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Random amount of padding, ignored by the receiver
  var padding: Data = Data()

  var platform: D2d_DeviceInfo.Platform = .unspecified

  /// Platform details (smartphone model / browser), e.g. "Firefox 91.0.2" or "iPhone 11 Pro"
  var platformDetails: String = String()

  /// App version, e.g. "4.52" (Android) or "4.6.12b2653" (iOS)
  var appVersion: String = String()

  /// User defined device label (e.g. "PC at Work"), may be empty if not set,
  /// max 255 characters
  var label: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Platform
  enum Platform: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Unknown platform
    case unspecified // = 0

    /// Android
    case android // = 1

    /// Apple iOS
    case ios // = 2

    /// Desktop application
    case desktop // = 3

    /// Web application
    case web // = 4
    case UNRECOGNIZED(Int)

    init() {
      self = .unspecified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .android
      case 2: self = .ios
      case 3: self = .desktop
      case 4: self = .web
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .android: return 1
      case .ios: return 2
      case .desktop: return 3
      case .web: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension D2d_DeviceInfo.Platform: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [D2d_DeviceInfo.Platform] = [
    .unspecified,
    .android,
    .ios,
    .desktop,
    .web,
  ]
}

#endif  // swift(>=4.2)

/// A transaction scope. Used in the d2m transaction messages.
struct D2d_TransactionScope {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var scope: D2d_TransactionScope.Scope = .userProfileSync

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Scope: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case userProfileSync // = 0
    case contactSync // = 1
    case groupSync // = 2
    case distributionListSync // = 3
    case settingsSync // = 4
    case newDeviceSync // = 5
    case UNRECOGNIZED(Int)

    init() {
      self = .userProfileSync
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .userProfileSync
      case 1: self = .contactSync
      case 2: self = .groupSync
      case 3: self = .distributionListSync
      case 4: self = .settingsSync
      case 5: self = .newDeviceSync
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .userProfileSync: return 0
      case .contactSync: return 1
      case .groupSync: return 2
      case .distributionListSync: return 3
      case .settingsSync: return 4
      case .newDeviceSync: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension D2d_TransactionScope.Scope: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [D2d_TransactionScope.Scope] = [
    .userProfileSync,
    .contactSync,
    .groupSync,
    .distributionListSync,
    .settingsSync,
    .newDeviceSync,
  ]
}

#endif  // swift(>=4.2)

/// Root message
struct D2d_Envelope {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Random amount of padding, ignored by the receiver
  var padding: Data = Data()

  /// The enveloped reflected message
  var content: D2d_Envelope.OneOf_Content? = nil

  var outgoingMessage: D2d_OutgoingMessage {
    get {
      if case .outgoingMessage(let v)? = content {return v}
      return D2d_OutgoingMessage()
    }
    set {content = .outgoingMessage(newValue)}
  }

  var outgoingMessageSent: D2d_OutgoingMessageSent {
    get {
      if case .outgoingMessageSent(let v)? = content {return v}
      return D2d_OutgoingMessageSent()
    }
    set {content = .outgoingMessageSent(newValue)}
  }

  var incomingMessage: D2d_IncomingMessage {
    get {
      if case .incomingMessage(let v)? = content {return v}
      return D2d_IncomingMessage()
    }
    set {content = .incomingMessage(newValue)}
  }

  var userProfileSync: D2d_UserProfileSync {
    get {
      if case .userProfileSync(let v)? = content {return v}
      return D2d_UserProfileSync()
    }
    set {content = .userProfileSync(newValue)}
  }

  var contactSync: D2d_ContactSync {
    get {
      if case .contactSync(let v)? = content {return v}
      return D2d_ContactSync()
    }
    set {content = .contactSync(newValue)}
  }

  var groupSync: D2d_GroupSync {
    get {
      if case .groupSync(let v)? = content {return v}
      return D2d_GroupSync()
    }
    set {content = .groupSync(newValue)}
  }

  var distributionListSync: D2d_DistributionListSync {
    get {
      if case .distributionListSync(let v)? = content {return v}
      return D2d_DistributionListSync()
    }
    set {content = .distributionListSync(newValue)}
  }

  var settingsSync: D2d_SettingsSync {
    get {
      if case .settingsSync(let v)? = content {return v}
      return D2d_SettingsSync()
    }
    set {content = .settingsSync(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The enveloped reflected message
  enum OneOf_Content: Equatable {
    case outgoingMessage(D2d_OutgoingMessage)
    case outgoingMessageSent(D2d_OutgoingMessageSent)
    case incomingMessage(D2d_IncomingMessage)
    case userProfileSync(D2d_UserProfileSync)
    case contactSync(D2d_ContactSync)
    case groupSync(D2d_GroupSync)
    case distributionListSync(D2d_DistributionListSync)
    case settingsSync(D2d_SettingsSync)

  #if !swift(>=4.1)
    static func ==(lhs: D2d_Envelope.OneOf_Content, rhs: D2d_Envelope.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.outgoingMessage, .outgoingMessage): return {
        guard case .outgoingMessage(let l) = lhs, case .outgoingMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.outgoingMessageSent, .outgoingMessageSent): return {
        guard case .outgoingMessageSent(let l) = lhs, case .outgoingMessageSent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.incomingMessage, .incomingMessage): return {
        guard case .incomingMessage(let l) = lhs, case .incomingMessage(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userProfileSync, .userProfileSync): return {
        guard case .userProfileSync(let l) = lhs, case .userProfileSync(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.contactSync, .contactSync): return {
        guard case .contactSync(let l) = lhs, case .contactSync(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.groupSync, .groupSync): return {
        guard case .groupSync(let l) = lhs, case .groupSync(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.distributionListSync, .distributionListSync): return {
        guard case .distributionListSync(let l) = lhs, case .distributionListSync(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.settingsSync, .settingsSync): return {
        guard case .settingsSync(let l) = lhs, case .settingsSync(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// A message receiver can be a single user or a group.
struct D2d_MessageReceiver {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The recipient's Threema ID or a group identity.
  var receiver: D2d_MessageReceiver.OneOf_Receiver? = nil

  var identity: String {
    get {
      if case .identity(let v)? = receiver {return v}
      return String()
    }
    set {receiver = .identity(newValue)}
  }

  var distributionList: UInt64 {
    get {
      if case .distributionList(let v)? = receiver {return v}
      return 0
    }
    set {receiver = .distributionList(newValue)}
  }

  var group: Common_GroupIdentity {
    get {
      if case .group(let v)? = receiver {return v}
      return Common_GroupIdentity()
    }
    set {receiver = .group(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The recipient's Threema ID or a group identity.
  enum OneOf_Receiver: Equatable {
    case identity(String)
    case distributionList(UInt64)
    case group(Common_GroupIdentity)

  #if !swift(>=4.1)
    static func ==(lhs: D2d_MessageReceiver.OneOf_Receiver, rhs: D2d_MessageReceiver.OneOf_Receiver) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.identity, .identity): return {
        guard case .identity(let l) = lhs, case .identity(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.distributionList, .distributionList): return {
        guard case .distributionList(let l) = lhs, case .distributionList(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.group, .group): return {
        guard case .group(let l) = lhs, case .group(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// An outgoing message, reflected to other devices.
struct D2d_OutgoingMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Recipient of the enclosed message.
  ///
  /// Note: If the receiver is a group identity, group and group creator id of
  ///       the enclosed message must match the values of the supplied group
  ///       identity. Otherwise, the message must be considered invalid.
  var receiver: D2d_MessageReceiver {
    get {return _receiver ?? D2d_MessageReceiver()}
    set {_receiver = newValue}
  }
  /// Returns true if `receiver` has been explicitly set.
  var hasReceiver: Bool {return self._receiver != nil}
  /// Clears the value of `receiver`. Subsequent reads from it will return its default value.
  mutating func clearReceiver() {self._receiver = nil}

  /// Unique ID of the enclosed message
  var messageID: UInt64 = 0

  /// Unix-ish timestamp in milliseconds for when the message has been created
  var createdAt: UInt64 = 0

  /// Enclosed message's type
  var type: D2d_MessageType = .invalid

  /// The message's body as defined for `Message` (0x01/0x02) of the Chat
  /// Server Protocol.
  var body: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _receiver: D2d_MessageReceiver? = nil
}

/// An outgoing message has been acknowledged by the chat server.
///
/// Note 1: The timestamp of the `reflect`/`reflect-ack` determines the
///         timestamp for when the message has been sent.
/// Note 2: This indicates that the message has been successfully stored in the
///         message queue of the server. It does NOT indicate that the message
///         has been delivered to the intended receiver.
struct D2d_OutgoingMessageSent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Recipient of the sent message.
  var receiver: D2d_MessageReceiver {
    get {return _receiver ?? D2d_MessageReceiver()}
    set {_receiver = newValue}
  }
  /// Returns true if `receiver` has been explicitly set.
  var hasReceiver: Bool {return self._receiver != nil}
  /// Clears the value of `receiver`. Subsequent reads from it will return its default value.
  mutating func clearReceiver() {self._receiver = nil}

  /// Unique ID of the sent message
  var messageID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _receiver: D2d_MessageReceiver? = nil
}

/// An incoming message, reflected to other devices.
///
/// Note: The timestamp of the `reflect`/`reflect-ack` determines the timestamp
///       for when the message has been received.
struct D2d_IncomingMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Sender's Threema ID
  var senderIdentity: String = String()

  /// Unique ID of the enclosed message
  var messageID: UInt64 = 0

  /// Unix-ish timestamp in milliseconds for when the message has been created
  /// Note: Take this value from the CSP `message` struct.
  var createdAt: UInt64 = 0

  /// Enclosed message's type
  var type: D2d_MessageType = .invalid

  /// The message's body as defined for `Message` (0x01/0x02) of the Chat
  /// Server Protocol.
  var body: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// User profile synchronisation message.
struct D2d_UserProfileSync {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Synchronisation type
  var action: D2d_UserProfileSync.OneOf_Action? = nil

  var set: D2d_UserProfileSync.Set {
    get {
      if case .set(let v)? = action {return v}
      return D2d_UserProfileSync.Set()
    }
    set {action = .set(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Synchronisation type
  enum OneOf_Action: Equatable {
    case set(D2d_UserProfileSync.Set)

  #if !swift(>=4.1)
    static func ==(lhs: D2d_UserProfileSync.OneOf_Action, rhs: D2d_UserProfileSync.OneOf_Action) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.set, .set): return {
        guard case .set(let l) = lhs, case .set(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// Update the user's profile
  struct Set {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var userProfile: Sync_UserProfile {
      get {return _userProfile ?? Sync_UserProfile()}
      set {_userProfile = newValue}
    }
    /// Returns true if `userProfile` has been explicitly set.
    var hasUserProfile: Bool {return self._userProfile != nil}
    /// Clears the value of `userProfile`. Subsequent reads from it will return its default value.
    mutating func clearUserProfile() {self._userProfile = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _userProfile: Sync_UserProfile? = nil
  }

  init() {}
}

/// Contact synchronisation message.
struct D2d_ContactSync {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Synchronisation type
  var action: D2d_ContactSync.OneOf_Action? = nil

  /// Create or update a Threema contact
  var set: D2d_ContactSync.Set {
    get {
      if case .set(let v)? = action {return v}
      return D2d_ContactSync.Set()
    }
    set {action = .set(newValue)}
  }

  /// Delete a Threema contact
  var delete: D2d_ContactSync.Delete {
    get {
      if case .delete(let v)? = action {return v}
      return D2d_ContactSync.Delete()
    }
    set {action = .delete(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Synchronisation type
  enum OneOf_Action: Equatable {
    /// Create or update a Threema contact
    case set(D2d_ContactSync.Set)
    /// Delete a Threema contact
    case delete(D2d_ContactSync.Delete)

  #if !swift(>=4.1)
    static func ==(lhs: D2d_ContactSync.OneOf_Action, rhs: D2d_ContactSync.OneOf_Action) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.set, .set): return {
        guard case .set(let l) = lhs, case .set(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.delete, .delete): return {
        guard case .delete(let l) = lhs, case .delete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Create or update a Threema contact.
  struct Set {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var contact: Sync_Contact {
      get {return _contact ?? Sync_Contact()}
      set {_contact = newValue}
    }
    /// Returns true if `contact` has been explicitly set.
    var hasContact: Bool {return self._contact != nil}
    /// Clears the value of `contact`. Subsequent reads from it will return its default value.
    mutating func clearContact() {self._contact = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _contact: Sync_Contact? = nil
  }

  /// Delete a Threema contact.
  struct Delete {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var deleteIdentity: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// Group synchronisation message.
struct D2d_GroupSync {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Synchronisation type
  var action: D2d_GroupSync.OneOf_Action? = nil

  /// Create or update a group
  var set: D2d_GroupSync.Set {
    get {
      if case .set(let v)? = action {return v}
      return D2d_GroupSync.Set()
    }
    set {action = .set(newValue)}
  }

  /// Delete a group
  var delete: D2d_GroupSync.Delete {
    get {
      if case .delete(let v)? = action {return v}
      return D2d_GroupSync.Delete()
    }
    set {action = .delete(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Synchronisation type
  enum OneOf_Action: Equatable {
    /// Create or update a group
    case set(D2d_GroupSync.Set)
    /// Delete a group
    case delete(D2d_GroupSync.Delete)

  #if !swift(>=4.1)
    static func ==(lhs: D2d_GroupSync.OneOf_Action, rhs: D2d_GroupSync.OneOf_Action) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.set, .set): return {
        guard case .set(let l) = lhs, case .set(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.delete, .delete): return {
        guard case .delete(let l) = lhs, case .delete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Create or update a group.
  struct Set {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var group: Sync_Group {
      get {return _group ?? Sync_Group()}
      set {_group = newValue}
    }
    /// Returns true if `group` has been explicitly set.
    var hasGroup: Bool {return self._group != nil}
    /// Clears the value of `group`. Subsequent reads from it will return its default value.
    mutating func clearGroup() {self._group = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _group: Sync_Group? = nil
  }

  /// Delete a group.
  struct Delete {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Unique group identity
    var groupIdentity: Common_GroupIdentity {
      get {return _groupIdentity ?? Common_GroupIdentity()}
      set {_groupIdentity = newValue}
    }
    /// Returns true if `groupIdentity` has been explicitly set.
    var hasGroupIdentity: Bool {return self._groupIdentity != nil}
    /// Clears the value of `groupIdentity`. Subsequent reads from it will return its default value.
    mutating func clearGroupIdentity() {self._groupIdentity = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _groupIdentity: Common_GroupIdentity? = nil
  }

  init() {}
}

/// Distribution list synchronisation message.
struct D2d_DistributionListSync {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Synchronisation type
  var action: D2d_DistributionListSync.OneOf_Action? = nil

  /// Create or update a distribution list
  var set: D2d_DistributionListSync.Set {
    get {
      if case .set(let v)? = action {return v}
      return D2d_DistributionListSync.Set()
    }
    set {action = .set(newValue)}
  }

  /// Delete a distribution list
  var delete: D2d_DistributionListSync.Delete {
    get {
      if case .delete(let v)? = action {return v}
      return D2d_DistributionListSync.Delete()
    }
    set {action = .delete(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Synchronisation type
  enum OneOf_Action: Equatable {
    /// Create or update a distribution list
    case set(D2d_DistributionListSync.Set)
    /// Delete a distribution list
    case delete(D2d_DistributionListSync.Delete)

  #if !swift(>=4.1)
    static func ==(lhs: D2d_DistributionListSync.OneOf_Action, rhs: D2d_DistributionListSync.OneOf_Action) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.set, .set): return {
        guard case .set(let l) = lhs, case .set(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.delete, .delete): return {
        guard case .delete(let l) = lhs, case .delete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Create or update a distribution list.
  struct Set {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var distributionList: Sync_DistributionList {
      get {return _distributionList ?? Sync_DistributionList()}
      set {_distributionList = newValue}
    }
    /// Returns true if `distributionList` has been explicitly set.
    var hasDistributionList: Bool {return self._distributionList != nil}
    /// Clears the value of `distributionList`. Subsequent reads from it will return its default value.
    mutating func clearDistributionList() {self._distributionList = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _distributionList: Sync_DistributionList? = nil
  }

  /// Delete a distribution list.
  struct Delete {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Unique ID of the distribution list
    var distributionListID: UInt64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// Settings synchronisation message.
struct D2d_SettingsSync {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Synchronisation type
  var action: D2d_SettingsSync.OneOf_Action? = nil

  var set: D2d_SettingsSync.Set {
    get {
      if case .set(let v)? = action {return v}
      return D2d_SettingsSync.Set()
    }
    set {action = .set(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Synchronisation type
  enum OneOf_Action: Equatable {
    case set(D2d_SettingsSync.Set)

  #if !swift(>=4.1)
    static func ==(lhs: D2d_SettingsSync.OneOf_Action, rhs: D2d_SettingsSync.OneOf_Action) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.set, .set): return {
        guard case .set(let l) = lhs, case .set(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// Apply settings
  struct Set {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var settings: Sync_Settings {
      get {return _settings ?? Sync_Settings()}
      set {_settings = newValue}
    }
    /// Returns true if `settings` has been explicitly set.
    var hasSettings: Bool {return self._settings != nil}
    /// Clears the value of `settings`. Subsequent reads from it will return its default value.
    mutating func clearSettings() {self._settings = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _settings: Sync_Settings? = nil
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "d2d"

extension D2d_MessageType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INVALID"),
    1: .same(proto: "TEXT"),
    2: .same(proto: "DEPRECATED_IMAGE"),
    16: .same(proto: "LOCATION"),
    19: .same(proto: "DEPRECATED_VIDEO"),
    20: .same(proto: "DEPRECATED_AUDIO"),
    21: .same(proto: "POLL_SETUP"),
    22: .same(proto: "POLL_VOTE"),
    23: .same(proto: "FILE"),
    24: .same(proto: "CONTACT_SET_PROFILE_PICTURE"),
    25: .same(proto: "CONTACT_DELETE_PROFILE_PICTURE"),
    26: .same(proto: "CONTACT_REQUEST_PROFILE_PICTURE"),
    65: .same(proto: "GROUP_TEXT"),
    66: .same(proto: "GROUP_LOCATION"),
    67: .same(proto: "GROUP_IMAGE"),
    68: .same(proto: "GROUP_VIDEO"),
    69: .same(proto: "GROUP_AUDIO"),
    70: .same(proto: "GROUP_FILE"),
    74: .same(proto: "GROUP_SETUP"),
    75: .same(proto: "GROUP_RENAME"),
    76: .same(proto: "GROUP_LEAVE"),
    80: .same(proto: "GROUP_SET_PROFILE_PICTURE"),
    81: .same(proto: "GROUP_REQUEST_SYNC"),
    82: .same(proto: "GROUP_POLL_SETUP"),
    83: .same(proto: "GROUP_POLL_VOTE"),
    84: .same(proto: "GROUP_DELETE_PROFILE_PICTURE"),
    96: .same(proto: "CALL_OFFER"),
    97: .same(proto: "CALL_ANSWER"),
    98: .same(proto: "CALL_ICE_CANDIDATE"),
    99: .same(proto: "CALL_HANGUP"),
    100: .same(proto: "CALL_RINGING"),
    128: .same(proto: "DELIVERY_RECEIPT"),
    144: .same(proto: "TYPING_INDICATOR"),
  ]
}

extension D2d_SharedDeviceData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SharedDeviceData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "padding"),
    2: .same(proto: "version"),
    3: .standard(proto: "mdm_parameters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.padding) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._mdmParameters) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.padding.isEmpty {
      try visitor.visitSingularBytesField(value: self.padding, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 2)
    }
    if let v = self._mdmParameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2d_SharedDeviceData, rhs: D2d_SharedDeviceData) -> Bool {
    if lhs.padding != rhs.padding {return false}
    if lhs.version != rhs.version {return false}
    if lhs._mdmParameters != rhs._mdmParameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_DeviceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DeviceInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "padding"),
    2: .same(proto: "platform"),
    3: .standard(proto: "platform_details"),
    4: .standard(proto: "app_version"),
    5: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.padding) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.platform) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.platformDetails) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.appVersion) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.padding.isEmpty {
      try visitor.visitSingularBytesField(value: self.padding, fieldNumber: 1)
    }
    if self.platform != .unspecified {
      try visitor.visitSingularEnumField(value: self.platform, fieldNumber: 2)
    }
    if !self.platformDetails.isEmpty {
      try visitor.visitSingularStringField(value: self.platformDetails, fieldNumber: 3)
    }
    if !self.appVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.appVersion, fieldNumber: 4)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2d_DeviceInfo, rhs: D2d_DeviceInfo) -> Bool {
    if lhs.padding != rhs.padding {return false}
    if lhs.platform != rhs.platform {return false}
    if lhs.platformDetails != rhs.platformDetails {return false}
    if lhs.appVersion != rhs.appVersion {return false}
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_DeviceInfo.Platform: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNSPECIFIED"),
    1: .same(proto: "ANDROID"),
    2: .same(proto: "IOS"),
    3: .same(proto: "DESKTOP"),
    4: .same(proto: "WEB"),
  ]
}

extension D2d_TransactionScope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionScope"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scope"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.scope) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.scope != .userProfileSync {
      try visitor.visitSingularEnumField(value: self.scope, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2d_TransactionScope, rhs: D2d_TransactionScope) -> Bool {
    if lhs.scope != rhs.scope {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_TransactionScope.Scope: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "USER_PROFILE_SYNC"),
    1: .same(proto: "CONTACT_SYNC"),
    2: .same(proto: "GROUP_SYNC"),
    3: .same(proto: "DISTRIBUTION_LIST_SYNC"),
    4: .same(proto: "SETTINGS_SYNC"),
    5: .same(proto: "NEW_DEVICE_SYNC"),
  ]
}

extension D2d_Envelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Envelope"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "padding"),
    2: .standard(proto: "outgoing_message"),
    3: .standard(proto: "outgoing_message_sent"),
    4: .standard(proto: "incoming_message"),
    5: .standard(proto: "user_profile_sync"),
    6: .standard(proto: "contact_sync"),
    7: .standard(proto: "group_sync"),
    8: .standard(proto: "distribution_list_sync"),
    9: .standard(proto: "settings_sync"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.padding) }()
      case 2: try {
        var v: D2d_OutgoingMessage?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .outgoingMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .outgoingMessage(v)
        }
      }()
      case 3: try {
        var v: D2d_OutgoingMessageSent?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .outgoingMessageSent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .outgoingMessageSent(v)
        }
      }()
      case 4: try {
        var v: D2d_IncomingMessage?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .incomingMessage(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .incomingMessage(v)
        }
      }()
      case 5: try {
        var v: D2d_UserProfileSync?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .userProfileSync(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .userProfileSync(v)
        }
      }()
      case 6: try {
        var v: D2d_ContactSync?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .contactSync(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .contactSync(v)
        }
      }()
      case 7: try {
        var v: D2d_GroupSync?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .groupSync(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .groupSync(v)
        }
      }()
      case 8: try {
        var v: D2d_DistributionListSync?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .distributionListSync(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .distributionListSync(v)
        }
      }()
      case 9: try {
        var v: D2d_SettingsSync?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .settingsSync(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .settingsSync(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.padding.isEmpty {
      try visitor.visitSingularBytesField(value: self.padding, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.content {
    case .outgoingMessage?: try {
      guard case .outgoingMessage(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .outgoingMessageSent?: try {
      guard case .outgoingMessageSent(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .incomingMessage?: try {
      guard case .incomingMessage(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .userProfileSync?: try {
      guard case .userProfileSync(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .contactSync?: try {
      guard case .contactSync(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .groupSync?: try {
      guard case .groupSync(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .distributionListSync?: try {
      guard case .distributionListSync(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .settingsSync?: try {
      guard case .settingsSync(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2d_Envelope, rhs: D2d_Envelope) -> Bool {
    if lhs.padding != rhs.padding {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_MessageReceiver: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MessageReceiver"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identity"),
    2: .standard(proto: "distribution_list"),
    3: .same(proto: "group"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.receiver != nil {try decoder.handleConflictingOneOf()}
          self.receiver = .identity(v)
        }
      }()
      case 2: try {
        var v: UInt64?
        try decoder.decodeSingularFixed64Field(value: &v)
        if let v = v {
          if self.receiver != nil {try decoder.handleConflictingOneOf()}
          self.receiver = .distributionList(v)
        }
      }()
      case 3: try {
        var v: Common_GroupIdentity?
        var hadOneofValue = false
        if let current = self.receiver {
          hadOneofValue = true
          if case .group(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.receiver = .group(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.receiver {
    case .identity?: try {
      guard case .identity(let v)? = self.receiver else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .distributionList?: try {
      guard case .distributionList(let v)? = self.receiver else { preconditionFailure() }
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 2)
    }()
    case .group?: try {
      guard case .group(let v)? = self.receiver else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2d_MessageReceiver, rhs: D2d_MessageReceiver) -> Bool {
    if lhs.receiver != rhs.receiver {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_OutgoingMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OutgoingMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "receiver"),
    2: .standard(proto: "message_id"),
    3: .standard(proto: "created_at"),
    4: .same(proto: "type"),
    5: .same(proto: "body"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._receiver) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.messageID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.createdAt) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.body) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._receiver {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.messageID != 0 {
      try visitor.visitSingularFixed64Field(value: self.messageID, fieldNumber: 2)
    }
    if self.createdAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdAt, fieldNumber: 3)
    }
    if self.type != .invalid {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 4)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularBytesField(value: self.body, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2d_OutgoingMessage, rhs: D2d_OutgoingMessage) -> Bool {
    if lhs._receiver != rhs._receiver {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.type != rhs.type {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_OutgoingMessageSent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OutgoingMessageSent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "receiver"),
    2: .standard(proto: "message_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._receiver) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.messageID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._receiver {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.messageID != 0 {
      try visitor.visitSingularFixed64Field(value: self.messageID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2d_OutgoingMessageSent, rhs: D2d_OutgoingMessageSent) -> Bool {
    if lhs._receiver != rhs._receiver {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_IncomingMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IncomingMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sender_identity"),
    2: .standard(proto: "message_id"),
    3: .standard(proto: "created_at"),
    5: .same(proto: "type"),
    6: .same(proto: "body"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.senderIdentity) }()
      case 2: try { try decoder.decodeSingularFixed64Field(value: &self.messageID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.createdAt) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.body) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.senderIdentity.isEmpty {
      try visitor.visitSingularStringField(value: self.senderIdentity, fieldNumber: 1)
    }
    if self.messageID != 0 {
      try visitor.visitSingularFixed64Field(value: self.messageID, fieldNumber: 2)
    }
    if self.createdAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdAt, fieldNumber: 3)
    }
    if self.type != .invalid {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 5)
    }
    if !self.body.isEmpty {
      try visitor.visitSingularBytesField(value: self.body, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2d_IncomingMessage, rhs: D2d_IncomingMessage) -> Bool {
    if lhs.senderIdentity != rhs.senderIdentity {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.type != rhs.type {return false}
    if lhs.body != rhs.body {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_UserProfileSync: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserProfileSync"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "set"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: D2d_UserProfileSync.Set?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .set(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .set(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .set(let v)? = self.action {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2d_UserProfileSync, rhs: D2d_UserProfileSync) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_UserProfileSync.Set: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = D2d_UserProfileSync.protoMessageName + ".Set"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_profile"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userProfile) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._userProfile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2d_UserProfileSync.Set, rhs: D2d_UserProfileSync.Set) -> Bool {
    if lhs._userProfile != rhs._userProfile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_ContactSync: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContactSync"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "set"),
    2: .same(proto: "delete"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: D2d_ContactSync.Set?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .set(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .set(v)
        }
      }()
      case 2: try {
        var v: D2d_ContactSync.Delete?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .delete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .delete(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.action {
    case .set?: try {
      guard case .set(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2d_ContactSync, rhs: D2d_ContactSync) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_ContactSync.Set: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = D2d_ContactSync.protoMessageName + ".Set"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contact"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._contact) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._contact {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2d_ContactSync.Set, rhs: D2d_ContactSync.Set) -> Bool {
    if lhs._contact != rhs._contact {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_ContactSync.Delete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = D2d_ContactSync.protoMessageName + ".Delete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "delete_identity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deleteIdentity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deleteIdentity.isEmpty {
      try visitor.visitSingularStringField(value: self.deleteIdentity, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2d_ContactSync.Delete, rhs: D2d_ContactSync.Delete) -> Bool {
    if lhs.deleteIdentity != rhs.deleteIdentity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_GroupSync: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupSync"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "set"),
    2: .same(proto: "delete"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: D2d_GroupSync.Set?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .set(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .set(v)
        }
      }()
      case 2: try {
        var v: D2d_GroupSync.Delete?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .delete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .delete(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.action {
    case .set?: try {
      guard case .set(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2d_GroupSync, rhs: D2d_GroupSync) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_GroupSync.Set: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = D2d_GroupSync.protoMessageName + ".Set"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._group) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._group {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2d_GroupSync.Set, rhs: D2d_GroupSync.Set) -> Bool {
    if lhs._group != rhs._group {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_GroupSync.Delete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = D2d_GroupSync.protoMessageName + ".Delete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_identity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._groupIdentity) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._groupIdentity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2d_GroupSync.Delete, rhs: D2d_GroupSync.Delete) -> Bool {
    if lhs._groupIdentity != rhs._groupIdentity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_DistributionListSync: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DistributionListSync"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "set"),
    2: .same(proto: "delete"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: D2d_DistributionListSync.Set?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .set(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .set(v)
        }
      }()
      case 2: try {
        var v: D2d_DistributionListSync.Delete?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .delete(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .delete(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.action {
    case .set?: try {
      guard case .set(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.action else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2d_DistributionListSync, rhs: D2d_DistributionListSync) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_DistributionListSync.Set: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = D2d_DistributionListSync.protoMessageName + ".Set"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "distribution_list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._distributionList) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._distributionList {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2d_DistributionListSync.Set, rhs: D2d_DistributionListSync.Set) -> Bool {
    if lhs._distributionList != rhs._distributionList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_DistributionListSync.Delete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = D2d_DistributionListSync.protoMessageName + ".Delete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "distribution_list_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.distributionListID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.distributionListID != 0 {
      try visitor.visitSingularFixed64Field(value: self.distributionListID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2d_DistributionListSync.Delete, rhs: D2d_DistributionListSync.Delete) -> Bool {
    if lhs.distributionListID != rhs.distributionListID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_SettingsSync: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SettingsSync"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "set"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: D2d_SettingsSync.Set?
        var hadOneofValue = false
        if let current = self.action {
          hadOneofValue = true
          if case .set(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.action = .set(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if case .set(let v)? = self.action {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2d_SettingsSync, rhs: D2d_SettingsSync) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2d_SettingsSync.Set: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = D2d_SettingsSync.protoMessageName + ".Set"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "settings"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._settings) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._settings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2d_SettingsSync.Set, rhs: D2d_SettingsSync.Set) -> Bool {
    if lhs._settings != rhs._settings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
