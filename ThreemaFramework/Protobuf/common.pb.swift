//  _____ _
// |_   _| |_  _ _ ___ ___ _ __  __ _
//   | | | ' \| '_/ -_) -_) '  \/ _` |_
//   |_| |_||_|_| \___\___|_|_|_\__,_(_)
//
// Threema iOS Client
// Copyright (c) 2020-2022 Threema GmbH
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License, version 3,
// as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Threema Blob to be uploaded/downloaded from the Blob server.
struct Common_Blob {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Blob ID as given by the Blob server
  var id: Data = SwiftProtobuf.Internal.emptyData

  /// Nonce used for encrypting/decrypting the Blob.
  /// Note: May be omitted if unambigously defined by the context.
  var nonce: Data = SwiftProtobuf.Internal.emptyData

  /// Secret (or public) key used for encrypting/decrypting the Blob.
  /// Note: May be omitted if unambigously defined by the context.
  var key: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Generic image.
struct Common_Image {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: Common_Image.TypeEnum = .jpeg

  /// The image's source
  var source: Common_Image.OneOf_Source? = nil

  /// The image's data needs to be downloaded from the Blob server
  var blob: Common_Blob {
    get {
      if case .blob(let v)? = source {return v}
      return Common_Blob()
    }
    set {source = .blob(newValue)}
  }

  /// The image's data is inlined.
  /// Note: This MUST only be used when explicitly allowed.
  ///       Almost always use a global/device group shared Blob instead!
  var data: Data {
    get {
      if case .data(let v)? = source {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {source = .data(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The image's source
  enum OneOf_Source: Equatable {
    /// The image's data needs to be downloaded from the Blob server
    case blob(Common_Blob)
    /// The image's data is inlined.
    /// Note: This MUST only be used when explicitly allowed.
    ///       Almost always use a global/device group shared Blob instead!
    case data(Data)

  #if !swift(>=4.1)
    static func ==(lhs: Common_Image.OneOf_Source, rhs: Common_Image.OneOf_Source) -> Bool {
      switch (lhs, rhs) {
      case (.blob(let l), .blob(let r)): return l == r
      case (.data(let l), .data(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  /// Format type of the image
  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case jpeg // = 0
    case UNRECOGNIZED(Int)

    init() {
      self = .jpeg
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .jpeg
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .jpeg: return 0
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Common_Image.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Common_Image.TypeEnum] = [
    .jpeg,
  ]
}

#endif  // swift(>=4.2)

/// Unique group identity.
struct Common_GroupIdentity {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Group id as chosen by the group's creator
  var groupID: UInt64 = 0

  /// Threema ID of the group's creator
  var creatorIdentity: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "common"

extension Common_Blob: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Blob"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "nonce"),
    3: .same(proto: "key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.id)
      case 2: try decoder.decodeSingularBytesField(value: &self.nonce)
      case 3: try decoder.decodeSingularBytesField(value: &self.key)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if !self.nonce.isEmpty {
      try visitor.visitSingularBytesField(value: self.nonce, fieldNumber: 2)
    }
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Common_Blob, rhs: Common_Blob) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_Image: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Image"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "blob"),
    3: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2:
        var v: Common_Blob?
        if let current = self.source {
          try decoder.handleConflictingOneOf()
          if case .blob(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.source = .blob(v)}
      case 3:
        if self.source != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.source = .data(v)}
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .jpeg {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    switch self.source {
    case .blob(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case .data(let v)?:
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Common_Image, rhs: Common_Image) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Common_Image.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "JPEG"),
  ]
}

extension Common_GroupIdentity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupIdentity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_id"),
    2: .standard(proto: "creator_identity"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularFixed64Field(value: &self.groupID)
      case 2: try decoder.decodeSingularStringField(value: &self.creatorIdentity)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularFixed64Field(value: self.groupID, fieldNumber: 1)
    }
    if !self.creatorIdentity.isEmpty {
      try visitor.visitSingularStringField(value: self.creatorIdentity, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Common_GroupIdentity, rhs: Common_GroupIdentity) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.creatorIdentity != rhs.creatorIdentity {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
