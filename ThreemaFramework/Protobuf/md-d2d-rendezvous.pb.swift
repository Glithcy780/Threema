// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: md-d2d-rendezvous.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// ## Connection Rendezvous Protocol (Supplementary)
//
// This is a supplementary section to the corresponding structbuf section
// with complementary protobuf messages. All defined messages here follow the
// same logic.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Network cost
enum Rendezvous_NetworkCost: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// It is unknown whether the interface is metered or unmetered
  case unknown // = 0

  /// The interface is unmetered
  case unmetered // = 1

  /// The interface is metered
  case metered // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .unmetered
    case 2: self = .metered
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .unmetered: return 1
    case .metered: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Rendezvous_NetworkCost: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Rendezvous_NetworkCost] = [
    .unknown,
    .unmetered,
    .metered,
  ]
}

#endif  // swift(>=4.2)

/// Contains the data necessary to initialise a 1:1 connection between two
/// devices.
///
/// When creating this message, run the following sub-steps simultaneously and
/// wait for them to finish:
///
/// 1. If the device is able to create a TCP server socket:
///    1. Bind to _any_ IP address with a random port number. Silently ignore
///       failures.
///    2. If successful, let `addresses` be the list of available IP addresses
///       on network interfaces the server has been bound to.
///    3. Drop any loopback and duplicate IP addresses from `addresses`.
///    4. Drop link-local IPv6 addresses associated to interfaces that only
///       provide link-local IPv6 addresses.
///    5. Sort `addresses` in the following way, highest priority first:
///         1. IP addresses on unmetered, fast networks
///         2. IP addresses on unmetered, slow networks
///         3. IP addresses on metered, fast networks
///         4. Any other addresses
///    6. Complete the subroutine and provide `addresses` and other necessary
///       data in the `direct_tcp_server` field.
/// 2. Connect to a WebSocket relay server:
///    1. Generate a random 32 byte hex-encoded rendezvous path.
///    2. Connect to the WebSocket relay server URL as provided by the context
///       with the generated hex-encoded rendezvous path.
///    3. Once connected, complete the subroutine and provide the necessary
///       data in the `relayed_web_socket` field.
///
/// When receiving this message:
///
/// 1. If any `path_id` is contained more than once, abort these steps.
/// 2. If the device is able to create a TCP client connection:
///    1. Let `addresses` be the IP addresses of `direct_tcp_server`.
///    2. Filter `addresses` by discarding IPs with unsupported families (e.g.
///       if the device has no IPv6 address, drop any IPv6 addresses).
///    3. For each IP address in `addresses`:
///       1. Connect to the given IP address in the background.
///       2. Wait 100ms.
/// 3. Connect to the provided relayed WebSocket server in the background.
/// 4. On each successful direct or relayed connection made in the background,
///    forward an event to the upper-level protocol in order for it to select
///    one of the paths for nomination.
struct Rendezvous_RendezvousInit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 32 byte secret key (RK)
  var key: Data = Data()

  var relayedWebSocket: Rendezvous_RendezvousInit.RelayedWebSocket {
    get {return _relayedWebSocket ?? Rendezvous_RendezvousInit.RelayedWebSocket()}
    set {_relayedWebSocket = newValue}
  }
  /// Returns true if `relayedWebSocket` has been explicitly set.
  var hasRelayedWebSocket: Bool {return self._relayedWebSocket != nil}
  /// Clears the value of `relayedWebSocket`. Subsequent reads from it will return its default value.
  mutating func clearRelayedWebSocket() {self._relayedWebSocket = nil}

  var directTcpServer: Rendezvous_RendezvousInit.DirectTcpServer {
    get {return _directTcpServer ?? Rendezvous_RendezvousInit.DirectTcpServer()}
    set {_directTcpServer = newValue}
  }
  /// Returns true if `directTcpServer` has been explicitly set.
  var hasDirectTcpServer: Bool {return self._directTcpServer != nil}
  /// Clears the value of `directTcpServer`. Subsequent reads from it will return its default value.
  mutating func clearDirectTcpServer() {self._directTcpServer = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Relayed WebSocket path
  struct RelayedWebSocket {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Unique path id
    var pathID: UInt32 = 0

    /// Network cost
    var networkCost: Rendezvous_NetworkCost = .unknown

    /// Full URL to the WebSocket server with a random 32 byte hex-encoded
    /// rendezvous path. Must begin with `wss://``.
    var url: String = String()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Direct path to a TCP server created by the initiator
  struct DirectTcpServer {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Random 16 bit port. Values greater than 65535 are invalid.
    var port: UInt32 = 0

    /// List of associated IP addresses. Each IP address creates its own path.
    var ipAddresses: [Rendezvous_RendezvousInit.DirectTcpServer.IpAddress] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// An IP address
    struct IpAddress {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Unique path id
      var pathID: UInt32 = 0

      /// Network cost
      var networkCost: Rendezvous_NetworkCost = .unknown

      /// IPv4 or IPv6 address
      var ip: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}
    }

    init() {}
  }

  init() {}

  fileprivate var _relayedWebSocket: Rendezvous_RendezvousInit.RelayedWebSocket? = nil
  fileprivate var _directTcpServer: Rendezvous_RendezvousInit.DirectTcpServer? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rendezvous"

extension Rendezvous_NetworkCost: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "UNMETERED"),
    2: .same(proto: "METERED"),
  ]
}

extension Rendezvous_RendezvousInit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RendezvousInit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "relayed_web_socket"),
    3: .standard(proto: "direct_tcp_server"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._relayedWebSocket) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._directTcpServer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 1)
    }
    if let v = self._relayedWebSocket {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._directTcpServer {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rendezvous_RendezvousInit, rhs: Rendezvous_RendezvousInit) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs._relayedWebSocket != rhs._relayedWebSocket {return false}
    if lhs._directTcpServer != rhs._directTcpServer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rendezvous_RendezvousInit.RelayedWebSocket: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Rendezvous_RendezvousInit.protoMessageName + ".RelayedWebSocket"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "path_id"),
    2: .standard(proto: "network_cost"),
    3: .same(proto: "url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.pathID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.networkCost) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pathID != 0 {
      try visitor.visitSingularUInt32Field(value: self.pathID, fieldNumber: 1)
    }
    if self.networkCost != .unknown {
      try visitor.visitSingularEnumField(value: self.networkCost, fieldNumber: 2)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rendezvous_RendezvousInit.RelayedWebSocket, rhs: Rendezvous_RendezvousInit.RelayedWebSocket) -> Bool {
    if lhs.pathID != rhs.pathID {return false}
    if lhs.networkCost != rhs.networkCost {return false}
    if lhs.url != rhs.url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rendezvous_RendezvousInit.DirectTcpServer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Rendezvous_RendezvousInit.protoMessageName + ".DirectTcpServer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "port"),
    2: .standard(proto: "ip_addresses"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.port) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.ipAddresses) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.port != 0 {
      try visitor.visitSingularUInt32Field(value: self.port, fieldNumber: 1)
    }
    if !self.ipAddresses.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ipAddresses, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rendezvous_RendezvousInit.DirectTcpServer, rhs: Rendezvous_RendezvousInit.DirectTcpServer) -> Bool {
    if lhs.port != rhs.port {return false}
    if lhs.ipAddresses != rhs.ipAddresses {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rendezvous_RendezvousInit.DirectTcpServer.IpAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Rendezvous_RendezvousInit.DirectTcpServer.protoMessageName + ".IpAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "path_id"),
    2: .standard(proto: "network_cost"),
    3: .same(proto: "ip"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self.pathID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.networkCost) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.ip) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.pathID != 0 {
      try visitor.visitSingularFixed32Field(value: self.pathID, fieldNumber: 1)
    }
    if self.networkCost != .unknown {
      try visitor.visitSingularEnumField(value: self.networkCost, fieldNumber: 2)
    }
    if !self.ip.isEmpty {
      try visitor.visitSingularStringField(value: self.ip, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Rendezvous_RendezvousInit.DirectTcpServer.IpAddress, rhs: Rendezvous_RendezvousInit.DirectTcpServer.IpAddress) -> Bool {
    if lhs.pathID != rhs.pathID {return false}
    if lhs.networkCost != rhs.networkCost {return false}
    if lhs.ip != rhs.ip {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
