// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: csp-e2e-fs.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// # Forward Security Subprotocol
//
// This protocol specifies forward security for end-to-end encrypted chat server
// messages. It is based on sessions established between two parties, where each
// session has a unique ID and is associated with ephemeral key material
// negotiated between the parties using ECDH key agreement and hash chain based
// key derivation.
//
// Each party is either an initiator or a responder in a given session. Once
// established, a session can be used for communication in either direction.
//
// Content messages can take any other type that could normally be sent without
// Forward Security, and wrap the message contained within using a separate
// cryptographic layer that provides Forward Security.
//
// TODO(SE-221): Add a section that describes when this subprotocol is being
// triggered and to which messages it is being applied.
//
// ## Terminology
//
// - FS: Forward Security
// - SI: Session Initiator
// - SR: Session Responder
// - 2DH: One-sided forward security with two DH calculations in the key
//   derivation
// - 4DH: Full two-sided forward security with four DH calculations in the key
//   derivation
//
// ## Modes
//
// An ECDH key negotiation normally needs active calculations by both involved
// parties before any actual messages can be exchanged. This is not practical in
// a messaging app, as the other party may not be online at the time when the
// first message(s) are sent.
//
// Thus, the protocol specifies two modes, called 2DH and 4DH.
//
// ### 2DH mode
//
// 2DH mode can be used immediately, even in a new session, as it does not
// involve any ECDH calculations from the peer (responder). However, it only
// protects against a compromise of the initiator's permanent secret key, not of
// the responder's permanent secret key. It is still better than sending all
// messages without Forward Security until a full two-sided session has been
// negotiated.
//
// ### 4DH mode
//
// A session enters 4DH mode once the responder has received and processed the
// initiator's `Init` message, and the resulting `Accept` message has been
// received by the initiator. At this point, ephemeral key material is available
// from the responder and is used in the ECDH calculations. Messages sent from
// this point on are secure even in the event of a future compromise of the
// permanent secret key of either party.
//
// The initiator should discard his 2DH key material after having received the
// `Accept` message. The responder should discard it after receiving the first
// message in 4DH mode, as no further messages in 2DH mode are to be expected
// (barring message reordering).
//
// ## Asymmetric keys
//
// Each party uses two different asymmetric Curve25519 key pairs:
//
// - myStaticKey (permanent key pair associated with Threema ID)
// - myEphemeralKey (ephemeral key pair generated for each session)
//
// The initiator needs to store `myEphemeralKey.private` until he has received
// the `Accept` message from the responder and should then erase it securely.
// The responder can discard his `myEphemeralKey.private` immediately after
// performing the initial chain key calculations (see below) and does not need
// to store it persistently for any amount of time.
//
// Each party also learns `peerEphemeralKey.public` from the
// `Init.ephemeral_public_key` or `Accept.ephemeral_public_key` message received
// from the peer. The `peerStaticKey.public` of the peer's Threema ID is assumed
// to be already known.
//
// ## Ratchets
//
// The two parties keep the following KDF ratchets per session:
//
// - myRatchet2DH (initiator only)
// - peerRatchet2DH (responder only)
// - myRatchet4DH (both parties)
// - peerRatchet4DH (both parties)
//
// For each ratchet, the current chain key and a counter (see below) are stored.
//
// The initiator calculates the initial chain keys as follows:
//
//     myRatchet2DH.chainKey = BLAKE2b(
//         key=ECDH(myStaticKey.private, peerStaticKey.public) ||
//             ECDH(myEphemeralKey.private, peerStaticKey.public),
//         salt="ke-2dh-<myThreemaId>", personal="3ma-e2e")
//
//     myRatchet4DH.chainKey = BLAKE2b(
//         key=BLAKE2b(
//                 ECDH(myStaticKey.private, peerStaticKey.public) ||
//                 ECDH(myEphemeralKey.private, peerStaticKey.public) ||
//                 ECDH(myStaticKey.private, peerEphemeralKey.public) ||
//                 ECDH(myEphemeralKey.private, peerEphemeralKey.public)
//             ),
//         salt="ke-4dh-<myThreemaId>", personal="3ma-e2e")
//
//     peerRatchet4DH.chainKey = BLAKE2b(
//         key=BLAKE2b(
//                 ECDH(myStaticKey.private, peerStaticKey.public) ||
//                 ECDH(myEphemeralKey.private, peerStaticKey.public) ||
//                 ECDH(myStaticKey.private, peerEphemeralKey.public) ||
//                 ECDH(myEphemeralKey.private, peerEphemeralKey.public)
//             ),
//         salt="ke-4dh-<peerThreemaId>", personal="3ma-e2e")
//
// The responder calculates the initial chain keys as follows:
//
//     peerRatchet2DH.chainKey = BLAKE2b(
//         key=ECDH(myStaticKey.private, peerStaticKey.public) ||
//             ECDH(myStaticKey.private, peerEphemeralKey.public),
//         salt="ke-2dh-<peerThreemaId>", personal="3ma-e2e")
//
//     myRatchet4DH.chainKey = BLAKE2b(
//         key=BLAKE2b(
//                 ECDH(myStaticKey.private, peerStaticKey.public) ||
//                 ECDH(myStaticKey.private, peerEphemeralKey.public) ||
//                 ECDH(myEphemeralKey.private, peerStaticKey.public) ||
//                 ECDH(myEphemeralKey.private, peerEphemeralKey.public)
//             ),
//         salt="ke-4dh-<myThreemaId>", personal="3ma-e2e")
//
//     peerRatchet4DH.chainKey = BLAKE2b(
//         key=BLAKE2b(
//                 ECDH(myStaticKey.private, peerStaticKey.public) ||
//                 ECDH(myStaticKey.private, peerEphemeralKey.public) ||
//                 ECDH(myEphemeralKey.private, peerStaticKey.public) ||
//                 ECDH(myEphemeralKey.private, peerEphemeralKey.public)
//             ),
//         salt="ke-4dh-<peerThreemaId>", personal="3ma-e2e")
//
// The ratchets are rotated after each message as follows:
//
//     ratchet.chainKey = BLAKE2b(key=ratchet.chainKey, salt="kdf-ck", personal="3ma-e2e")
//
// From the current chain key, an encryption key for the actual message is
// derived as follows:
//
//     encryptionKey = BLAKE2b(key=ratchet.chainKey, salt="kdf-aek", personal="3ma-e2e")
//
// Notes:
//
// - The only difference between the "my" and "peer" ratchets for each mode is
//   the Threema ID that is included in the salt.
// - The ECDH() function is the one from NaCl, i.e. crypto_box_beforenm(), which
//   applies a HSalsa20 step to the raw Curve25519 output.
// - BLAKE2b is used twice for 4DH. This is because it can only accept up to 64
//   bytes as its key input, but 128 bytes are provided in 4DH mode. In the
//   inner application, it is simply used as a hash function with 64 bytes
//   output and no parameters. In the outer application, it is used as a KDF
//   with key/salt/personal parameters, but no input.
//
// ### Ratchet counters
//
// Each session, direction and type (2DH/4DH) is associated with a counter,
// which describes how many times the KDF ratchet has been turned since the
// initial ECDH based key negotiation. Whenever a new message has been sent in a
// session, the corresponding counter must be incremented and the ratchet must
// be turned. As a KDF ratchet operation cannot be reversed, counter values
// cannot go back, and the original message order must be preserved during
// transport over the network and during processing on both sides.
//
// To account for lost messages (e.g. when the recipient has been offline for an
// extended period of time), either party must be prepared to accept counters
// that have skipped a few values, and turn the KDF ratchet as many times as is
// needed to reach the new counter value. To limit the CPU impact on the
// responder side, the permissible counter increment is limited to 10'000.
//
// ## Usual Protocol Flow
//
// A forward security session negotiation is typically started when a user sends
// the first message to a peer. The user assumes the role of the session
// initiator, creates a new session and sends an `Init` message, followed by any
// number of encapsulated `Message`s in 2DH mode.
//
//     SI -- Init -----------> SR   [1]
//     SI -- Message (2DH) --> SR   [0..N]
//
// At this point, SI established a session in 2DH mode for messages flowing from
// SI to SR.
//
// The session responder will then eventually process the `Init` and `Accept`
// the session.
//
//     SR -- Accept ---------> SI   [1]
//
// At that point, the session has been upgraded to 4DH mode for future messages
// sent between SI and SR.
//
//     SR -- Message (4DH) --> SI   [0..N]
//     SI -- Message (4DH) --> SR   [0..N]
//     ...
//
// At any point either party may `Terminate` a session, for example when the
// user is about to delete their account (or FS session information) and wants
// to notify the peer that the key material should be discarded.
//
// If any party receives a `Message` that it cannot decrypt (e.g. due to having
// lost the FS key material), it sends a `Reject` message to inform the other
// party that it can no longer use this particular FS session, and also tells it
// the ID of the message that could not be decrypted. The sender can then (after
// manual confirmation by the user) send the message again in a new FS session.
//
// ## Handling data loss
//
// A party could lose their stored forward security session information, e.g.
// due to reinstallation or relocation of the app to a new device. Forward
// security sessions are not included in backups, as this would conflict with
// their ephemeralness. When a party receives a message that it cannot decrypt
// due to missing session information, it signals this to the other party using
// a Reject message. Also, upon receiving an Init message, the receiving party
// can assume that the sender does not have any existing session information,
// and should thus delete any 4DH sessions on its side. 2DH sessions (i.e. those
// initiated by the party that has not lost the data) should not be deleted, as
// this could interfere with race condition resolution (see below).
//
// ## Race Conditions
//
// It is possible for both parties to start a negotiation independently, before
// having received the other party's `Init`. They should proceed normally to
// ensure any messages sent during the race will be received. However, when
// choosing a session for sending a new message and there is more than one
// session in 4DH mode available for the desired peer, the one with the lowest
// session ID should be used. This will ensure both parties will eventually
// start using the same session in both directions.
//
// ### Pruning unused sessions
//
// As soon as a 4DH message has been received from the peer in what is currently
// considered the lowest session ID by the receiving party, other leftover
// sessions should be discarded.
//
// ## Informing the user
//
// To prevent undetected MITM attacks by a third party that has gained access to
// the permanent private key of either party, the user should be informed
// whenever a new session is negotiated or a non-FS message has been received
// even though an FS session was available.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct CspE2eFs_ForwardSecurityEnvelope {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Forward security session ID, 16 bytes
  var sessionID: Data = Data()

  var content: CspE2eFs_ForwardSecurityEnvelope.OneOf_Content? = nil

  var init_p: CspE2eFs_ForwardSecurityEnvelope.Init {
    get {
      if case .init_p(let v)? = content {return v}
      return CspE2eFs_ForwardSecurityEnvelope.Init()
    }
    set {content = .init_p(newValue)}
  }

  var accept: CspE2eFs_ForwardSecurityEnvelope.Accept {
    get {
      if case .accept(let v)? = content {return v}
      return CspE2eFs_ForwardSecurityEnvelope.Accept()
    }
    set {content = .accept(newValue)}
  }

  var reject: CspE2eFs_ForwardSecurityEnvelope.Reject {
    get {
      if case .reject(let v)? = content {return v}
      return CspE2eFs_ForwardSecurityEnvelope.Reject()
    }
    set {content = .reject(newValue)}
  }

  var terminate: CspE2eFs_ForwardSecurityEnvelope.Terminate {
    get {
      if case .terminate(let v)? = content {return v}
      return CspE2eFs_ForwardSecurityEnvelope.Terminate()
    }
    set {content = .terminate(newValue)}
  }

  var message: CspE2eFs_ForwardSecurityEnvelope.Message {
    get {
      if case .message(let v)? = content {return v}
      return CspE2eFs_ForwardSecurityEnvelope.Message()
    }
    set {content = .message(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Content: Equatable {
    case init_p(CspE2eFs_ForwardSecurityEnvelope.Init)
    case accept(CspE2eFs_ForwardSecurityEnvelope.Accept)
    case reject(CspE2eFs_ForwardSecurityEnvelope.Reject)
    case terminate(CspE2eFs_ForwardSecurityEnvelope.Terminate)
    case message(CspE2eFs_ForwardSecurityEnvelope.Message)

  #if !swift(>=4.1)
    static func ==(lhs: CspE2eFs_ForwardSecurityEnvelope.OneOf_Content, rhs: CspE2eFs_ForwardSecurityEnvelope.OneOf_Content) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.init_p, .init_p): return {
        guard case .init_p(let l) = lhs, case .init_p(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.accept, .accept): return {
        guard case .accept(let l) = lhs, case .accept(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reject, .reject): return {
        guard case .reject(let l) = lhs, case .reject(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.terminate, .terminate): return {
        guard case .terminate(let l) = lhs, case .terminate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.message, .message): return {
        guard case .message(let l) = lhs, case .message(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  /// Establish a new FS session. The initiator picks a new random session ID.
  struct Init {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Ephemeral public key of the initiator for this session
    var ephemeralPublicKey: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Accept a newly established session as a responder. The session ID is
  /// equal to the one of the initiator.
  struct Accept {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Ephemeral public key of the responder for this session
    var ephemeralPublicKey: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Sent when receiving a `Message` that cannot be decrypted (e.g. because
  /// the recipient has lost the session information).
  ///
  /// The peer should discard the FS session and start a new one, if possible.
  struct Reject {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Message ID of the message that could not be decrypted and that should be
    /// sent again in a new session or without a session.
    var rejectedMessageID: UInt64 = 0

    var cause: CspE2eFs_ForwardSecurityEnvelope.Reject.Cause = .stateMismatch

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Cause for the reject.
    enum Cause: SwiftProtobuf.Enum {
      typealias RawValue = Int

      /// General state mismatch. Explicitly includes the following cases:
      ///
      /// - A `Message` could not be decrypted.
      /// - The DH type of a `Message` does not match the expected DH type.
      case stateMismatch // = 0

      /// The Session ID a `Message` was delivered with is not associated to a
      /// known session
      case unknownSession // = 1

      /// Signals that forward security has been explicitly disabled in response
      /// to an `Init`, `Accept` or `Message`.
      case disabled // = 2
      case UNRECOGNIZED(Int)

      init() {
        self = .stateMismatch
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .stateMismatch
        case 1: self = .unknownSession
        case 2: self = .disabled
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .stateMismatch: return 0
        case .unknownSession: return 1
        case .disabled: return 2
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  /// Signals that the sender will not send any further `Message`s in this
  /// session. The recipient should discard all key material related to this
  /// session.
  struct Terminate {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  /// Encapsulates another CSP E2EE message, adding forward security.
  struct Message {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var dhType: CspE2eFs_ForwardSecurityEnvelope.Message.DHType = .twodh

    /// A monotonically increasing counter, starting at 1 for the first 2DH or
    /// 4DH `Message` sent in this session, and incrementing by 1 for each
    /// successive `Message`.
    ///
    /// - Counters for 2DH and 4DH are separate, as they are based on different
    ///   root keys.
    /// - Counters for each direction are separate.
    /// - Can be used by the recipient as a hint of how many times to
    ///   rotate/ratchet the KDF, in case an intermediate `Message` went missing.
    var counter: UInt64 = 0

    /// A message defined in `e2e.container`, encrypted by the keys negotiated
    /// for FS in this session.
    ///
    /// An inner E2EE message of type `0xa0` is disallowed and **must** be
    /// discarded.
    var message: Data = Data()

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Whether 2DH or 4DH was used in deriving the key for encrypting this
    /// message.
    enum DHType: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case twodh // = 0
      case fourdh // = 1
      case UNRECOGNIZED(Int)

      init() {
        self = .twodh
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .twodh
        case 1: self = .fourdh
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      var rawValue: Int {
        switch self {
        case .twodh: return 0
        case .fourdh: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    init() {}
  }

  init() {}
}

#if swift(>=4.2)

extension CspE2eFs_ForwardSecurityEnvelope.Reject.Cause: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CspE2eFs_ForwardSecurityEnvelope.Reject.Cause] = [
    .stateMismatch,
    .unknownSession,
    .disabled,
  ]
}

extension CspE2eFs_ForwardSecurityEnvelope.Message.DHType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [CspE2eFs_ForwardSecurityEnvelope.Message.DHType] = [
    .twodh,
    .fourdh,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "csp_e2e_fs"

extension CspE2eFs_ForwardSecurityEnvelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ForwardSecurityEnvelope"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "session_id"),
    2: .same(proto: "init"),
    3: .same(proto: "accept"),
    4: .same(proto: "reject"),
    5: .same(proto: "terminate"),
    6: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.sessionID) }()
      case 2: try {
        var v: CspE2eFs_ForwardSecurityEnvelope.Init?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .init_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .init_p(v)
        }
      }()
      case 3: try {
        var v: CspE2eFs_ForwardSecurityEnvelope.Accept?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .accept(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .accept(v)
        }
      }()
      case 4: try {
        var v: CspE2eFs_ForwardSecurityEnvelope.Reject?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .reject(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .reject(v)
        }
      }()
      case 5: try {
        var v: CspE2eFs_ForwardSecurityEnvelope.Terminate?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .terminate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .terminate(v)
        }
      }()
      case 6: try {
        var v: CspE2eFs_ForwardSecurityEnvelope.Message?
        var hadOneofValue = false
        if let current = self.content {
          hadOneofValue = true
          if case .message(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.content = .message(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularBytesField(value: self.sessionID, fieldNumber: 1)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.content {
    case .init_p?: try {
      guard case .init_p(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .accept?: try {
      guard case .accept(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .reject?: try {
      guard case .reject(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .terminate?: try {
      guard case .terminate(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .message?: try {
      guard case .message(let v)? = self.content else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CspE2eFs_ForwardSecurityEnvelope, rhs: CspE2eFs_ForwardSecurityEnvelope) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CspE2eFs_ForwardSecurityEnvelope.Init: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CspE2eFs_ForwardSecurityEnvelope.protoMessageName + ".Init"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ephemeral_public_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.ephemeralPublicKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ephemeralPublicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.ephemeralPublicKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CspE2eFs_ForwardSecurityEnvelope.Init, rhs: CspE2eFs_ForwardSecurityEnvelope.Init) -> Bool {
    if lhs.ephemeralPublicKey != rhs.ephemeralPublicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CspE2eFs_ForwardSecurityEnvelope.Accept: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CspE2eFs_ForwardSecurityEnvelope.protoMessageName + ".Accept"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ephemeral_public_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.ephemeralPublicKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ephemeralPublicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.ephemeralPublicKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CspE2eFs_ForwardSecurityEnvelope.Accept, rhs: CspE2eFs_ForwardSecurityEnvelope.Accept) -> Bool {
    if lhs.ephemeralPublicKey != rhs.ephemeralPublicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CspE2eFs_ForwardSecurityEnvelope.Reject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CspE2eFs_ForwardSecurityEnvelope.protoMessageName + ".Reject"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rejected_message_id"),
    2: .same(proto: "cause"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.rejectedMessageID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.cause) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rejectedMessageID != 0 {
      try visitor.visitSingularFixed64Field(value: self.rejectedMessageID, fieldNumber: 1)
    }
    if self.cause != .stateMismatch {
      try visitor.visitSingularEnumField(value: self.cause, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CspE2eFs_ForwardSecurityEnvelope.Reject, rhs: CspE2eFs_ForwardSecurityEnvelope.Reject) -> Bool {
    if lhs.rejectedMessageID != rhs.rejectedMessageID {return false}
    if lhs.cause != rhs.cause {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CspE2eFs_ForwardSecurityEnvelope.Reject.Cause: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_MISMATCH"),
    1: .same(proto: "UNKNOWN_SESSION"),
    2: .same(proto: "DISABLED"),
  ]
}

extension CspE2eFs_ForwardSecurityEnvelope.Terminate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CspE2eFs_ForwardSecurityEnvelope.protoMessageName + ".Terminate"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CspE2eFs_ForwardSecurityEnvelope.Terminate, rhs: CspE2eFs_ForwardSecurityEnvelope.Terminate) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CspE2eFs_ForwardSecurityEnvelope.Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = CspE2eFs_ForwardSecurityEnvelope.protoMessageName + ".Message"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dh_type"),
    2: .same(proto: "counter"),
    3: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.dhType) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.counter) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dhType != .twodh {
      try visitor.visitSingularEnumField(value: self.dhType, fieldNumber: 1)
    }
    if self.counter != 0 {
      try visitor.visitSingularUInt64Field(value: self.counter, fieldNumber: 2)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularBytesField(value: self.message, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CspE2eFs_ForwardSecurityEnvelope.Message, rhs: CspE2eFs_ForwardSecurityEnvelope.Message) -> Bool {
    if lhs.dhType != rhs.dhType {return false}
    if lhs.counter != rhs.counter {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CspE2eFs_ForwardSecurityEnvelope.Message.DHType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TWODH"),
    1: .same(proto: "FOURDH"),
  ]
}
