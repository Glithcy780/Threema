// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: md-d2m.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// ## Device to Mediator Protocol (Supplementary)
//
// This is a supplementary section to the corresponding structbuf section
// with complementary messages that use protobuf instead of structbuf. All
// defined messages here follow the same logic.
//
// Note that all messages defined here, with the exception of `ClientUrlInfo`,
// are wrapped by `payload.container`.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// D2M protocol versions (32 bit).
enum D2m_ProtocolVersion: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Initial D2M protocol version (alpha, may break).
  case initial // = 0
  case UNRECOGNIZED(Int)

  init() {
    self = .initial
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .initial
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .initial: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension D2m_ProtocolVersion: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [D2m_ProtocolVersion] = [
    .initial,
  ]
}

#endif  // swift(>=4.2)

/// Policy determining the device slot's lifetime.
enum D2m_DeviceSlotExpirationPolicy: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// The device slot should be removed shortly after the device
  /// disconnected. However, there should be a delay of several minutes to
  /// ensure that the device can reconnect if it disconnected unintentionally.
  case volatile // = 0

  /// The device slot should be kept as long as possible
  case persistent // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .volatile
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .volatile
    case 1: self = .persistent
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .volatile: return 0
    case .persistent: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension D2m_DeviceSlotExpirationPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [D2m_DeviceSlotExpirationPolicy] = [
    .volatile,
    .persistent,
  ]
}

#endif  // swift(>=4.2)

/// Device registration state on the mediator server.
enum D2m_DeviceSlotState: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// A new device slot has been allocated for the device (i.e. the device's
  /// id was not registered on the server).
  case new // = 0

  /// An existing device slot has been reused for the device (i.e. the
  /// device's id is already registered on the server).
  case existing // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .new
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .new
    case 1: self = .existing
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .new: return 0
    case .existing: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension D2m_DeviceSlotState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [D2m_DeviceSlotState] = [
    .new,
    .existing,
  ]
}

#endif  // swift(>=4.2)

/// Send along client information when connecting to the mediator server.
///
/// This message is serialized, hex-encoded (lowercase) and then used as the
/// WebSocket path.
///
/// Type: n/a
/// Direction: Client -> Server
struct D2m_ClientUrlInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 32 byte device group id (`DGPK.public`)
  var deviceGroupID: Data = Data()

  /// Server group, as assigned by the server when the Threema identity has been
  /// created. Must consist of only digits or ASCII letters (`^[0-9a-zA-Z]+$`).
  var serverGroup: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Initial message from the server, containing an authentication challenge.
///
/// Type: 0x10
/// Direction: Client <-- Server
struct D2m_ServerHello {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Highest protocol version (`ProtocolVersion`) the server supports.
  var version: UInt32 = 0

  /// 32 byte ephemeral server key (`ESK.public`)
  var esk: Data = Data()

  /// 32 byte random challenge
  var challenge: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Initial message from the client, containing the authentication challenge
/// response and additional login information.
///
/// Type: 0x11
/// Direction: Client --> Server
struct D2m_ClientHello {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Protocol version (`ProtocolVersion`) which the client has selected.
  var version: UInt32 = 0

  /// Challenge response (72 bytes) for authentication.
  ///
  /// The response is created by encrypting the server's challenge in the
  /// following way:
  ///
  ///     XSalsa20-Poly1305(
  ///       key=X25519HSalsa20(DGPK.secret, ESK.public),
  ///       nonce=<random>,
  ///     )
  ///
  /// The nonce is then prefixed to the encrypted challenge.
  var response: Data = Data()

  /// Unique device id
  var deviceID: UInt64 = 0

  var deviceSlotsExhaustedPolicy: D2m_ClientHello.DeviceSlotsExhaustedPolicy = .reject

  /// Policy determining the device slot's lifetime
  var deviceSlotExpirationPolicy: D2m_DeviceSlotExpirationPolicy = .volatile

  /// The expected device slot state on the server.
  ///
  /// If set, and if the expected device slot state does not match the actual
  /// device slot state, the device will be dropped by the mediator server with
  /// the close code `4115` before being registered.
  var expectedDeviceSlotState: D2m_DeviceSlotState {
    get {return _expectedDeviceSlotState ?? .new}
    set {_expectedDeviceSlotState = newValue}
  }
  /// Returns true if `expectedDeviceSlotState` has been explicitly set.
  var hasExpectedDeviceSlotState: Bool {return self._expectedDeviceSlotState != nil}
  /// Clears the value of `expectedDeviceSlotState`. Subsequent reads from it will return its default value.
  mutating func clearExpectedDeviceSlotState() {self._expectedDeviceSlotState = nil}

  /// Device info (`d2d.DeviceInfo`), encrypted by `DGDIK.secret` and prefixed
  /// with a random nonce.
  var encryptedDeviceInfo: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Policy to be applied in case the device id is not registered on the server
  /// and all device slots have been exhausted.
  enum DeviceSlotsExhaustedPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Terminate the connection
    case reject // = 0

    /// Drop the least recently used device
    case dropLeastRecent // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .reject
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .reject
      case 1: self = .dropLeastRecent
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .reject: return 0
      case .dropLeastRecent: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _expectedDeviceSlotState: D2m_DeviceSlotState? = nil
}

#if swift(>=4.2)

extension D2m_ClientHello.DeviceSlotsExhaustedPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [D2m_ClientHello.DeviceSlotsExhaustedPolicy] = [
    .reject,
    .dropLeastRecent,
  ]
}

#endif  // swift(>=4.2)

/// Parts of the server's configuration and the device slot state.
///
/// Type: 0x12
/// Direction: Client <-- Server
struct D2m_ServerInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Current Unix-ish timestamp in milliseconds of the server.
  ///
  /// If the client's current timestamp deviates by more than 20 minutes, the
  /// client should disconnect and prompt the user to synchronise its clock.
  /// The user should also have an option to _connect anyway_ which should be
  /// cached for a reasonable amount of time.
  var currentTime: UInt64 = 0

  /// Maximum number of device slots
  var maxDeviceSlots: UInt32 = 0

  /// Informs the device about its device slot state on the server
  var deviceSlotState: D2m_DeviceSlotState = .new

  /// Device data shared among devices (`SharedDeviceData`), encrypted by
  /// `DGSDDK.secret` and prefixed with a random nonce.
  var encryptedSharedDeviceData: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The device's reflection queue on the server has been fully transmitted to
/// the device.
///
/// Note: This does not mean that reflected messages have already been
///       acknowledged by the device!
///
/// Type: 0x20
/// Direction: Client <-- Server
struct D2m_ReflectionQueueDry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The device's role has been promoted to leader, indicating that the device
/// should now request to receive and reflect messages from the chat server.
///
/// Type: 0x21
/// Direction: Client <-- Server
struct D2m_RolePromotedToLeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request device information of all devices.
///
/// Type: 0x30
/// Direction: Client --> Server
struct D2m_GetDevicesInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Device information of all devices.
///
/// Type: 0x31
/// Direction: Client <-- Server
struct D2m_DevicesInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var augmentedDeviceInfo: Dictionary<UInt64,D2m_DevicesInfo.AugmentedDeviceInfo> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Device id to (augmented) device info map of all devices.
  struct AugmentedDeviceInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Device info (`d2d.DeviceInfo`), encrypted by `DGDIK.secret` and prefixed
    /// with a random nonce.
    var encryptedDeviceInfo: Data = Data()

    /// Unix-ish timestamp in milliseconds containing the most recent login
    /// time of the device.
    var lastLoginAt: UInt64 = 0

    /// Expiration policy of the device.
    var deviceSlotExpirationPolicy: D2m_DeviceSlotExpirationPolicy = .volatile

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// Request to drop a device and free its device slot.
///
/// Type: 0x32
/// Direction: Client --> Server
struct D2m_DropDevice {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique device id
  var deviceID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Acknowledges that a device has been dropped and the device slot has been
/// free'd.
///
/// Type: 0x33
/// Direction: Client <-- Server
struct D2m_DropDeviceAck {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique device id
  var deviceID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Set the shared device data which is being sent to each device during login.
///
/// Type: 0x34
/// Direction: Client --> Server
struct D2m_SetSharedDeviceData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Device data shared among devices (`d2d.SharedDeviceData`), encrypted by
  /// `DGSDDK.secret` and prefixed with a random nonce.
  var encryptedSharedDeviceData: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Acquires a device group lock for an atomic operation shared across the
/// device group.
///
/// Reflection messages from the device to the mediator server will only be
/// reflected once the transaction is committed.
///
/// Type: 0x40
/// Direction: Client --> Server
struct D2m_BeginTransaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The transaction scope (`d2d.TransactionScope`), encrypted by
  /// `DGTSK.secret` and prefixed with a random nonce.
  var encryptedScope: Data = Data()

  /// Time-to-live in seconds for this transaction. Once the TTL is reached, the
  /// mediator server will abort the transaction and disconnect the client. When
  /// set to `0`, the server's maximum transaction TTL will be used.
  var ttl: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Acknowledges that the device group lock has been acquired and that the
/// transaction has been started.
///
/// Type: 0x41
/// Direction: Client <-- Server
struct D2m_BeginTransactionAck {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Commits a transaction, releases a device group lock.
///
/// Type: 0x42
/// Direction: Client --> Server
struct D2m_CommitTransaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Acknowledges that the transaction has been committed and that the device
/// group lock has been released.
///
/// Type: 0x43
/// Direction: Client <-- Server
struct D2m_CommitTransactionAck {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A `BeginTransaction` request is rejected because another transaction is
/// already in process.
///
/// Type: 0x44
/// Direction: Client <-- Server
struct D2m_TransactionRejected {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The device that currently holds the lock
  var deviceID: UInt64 = 0

  /// The encrypted transaction scope (`d2d.TransactionScope`) associated with
  /// the currently locked transaction, encrypted by `DGTSK.secret` and prefixed
  /// with a random nonce.
  var encryptedScope: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// When a transaction ends (either because it was committed or because the
/// device disconnected), this message is sent to all connected devices except
/// for the device that committed the transaction.
///
/// This can be used by the other devices as a "retry signal" if a previous
/// "BeginTransaction" attempt was unsuccessful.
///
/// Type: 0x45
/// Direction: Client <-- Server
struct D2m_TransactionEnded {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The device that held the lock up until now
  var deviceID: UInt64 = 0

  /// The encrypted transaction scope (`d2d.TransactionScope`) associated with
  /// the transaction that just ended, encrypted by `DGTSK.secret` and prefixed
  /// with a random nonce.
  var encryptedScope: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension D2m_ProtocolVersion: @unchecked Sendable {}
extension D2m_DeviceSlotExpirationPolicy: @unchecked Sendable {}
extension D2m_DeviceSlotState: @unchecked Sendable {}
extension D2m_ClientUrlInfo: @unchecked Sendable {}
extension D2m_ServerHello: @unchecked Sendable {}
extension D2m_ClientHello: @unchecked Sendable {}
extension D2m_ClientHello.DeviceSlotsExhaustedPolicy: @unchecked Sendable {}
extension D2m_ServerInfo: @unchecked Sendable {}
extension D2m_ReflectionQueueDry: @unchecked Sendable {}
extension D2m_RolePromotedToLeader: @unchecked Sendable {}
extension D2m_GetDevicesInfo: @unchecked Sendable {}
extension D2m_DevicesInfo: @unchecked Sendable {}
extension D2m_DevicesInfo.AugmentedDeviceInfo: @unchecked Sendable {}
extension D2m_DropDevice: @unchecked Sendable {}
extension D2m_DropDeviceAck: @unchecked Sendable {}
extension D2m_SetSharedDeviceData: @unchecked Sendable {}
extension D2m_BeginTransaction: @unchecked Sendable {}
extension D2m_BeginTransactionAck: @unchecked Sendable {}
extension D2m_CommitTransaction: @unchecked Sendable {}
extension D2m_CommitTransactionAck: @unchecked Sendable {}
extension D2m_TransactionRejected: @unchecked Sendable {}
extension D2m_TransactionEnded: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "d2m"

extension D2m_ProtocolVersion: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INITIAL"),
  ]
}

extension D2m_DeviceSlotExpirationPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "VOLATILE"),
    1: .same(proto: "PERSISTENT"),
  ]
}

extension D2m_DeviceSlotState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NEW"),
    1: .same(proto: "EXISTING"),
  ]
}

extension D2m_ClientUrlInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientUrlInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_group_id"),
    3: .standard(proto: "server_group"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.deviceGroupID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.serverGroup) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceGroupID.isEmpty {
      try visitor.visitSingularBytesField(value: self.deviceGroupID, fieldNumber: 1)
    }
    if !self.serverGroup.isEmpty {
      try visitor.visitSingularStringField(value: self.serverGroup, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2m_ClientUrlInfo, rhs: D2m_ClientUrlInfo) -> Bool {
    if lhs.deviceGroupID != rhs.deviceGroupID {return false}
    if lhs.serverGroup != rhs.serverGroup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_ServerHello: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerHello"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "esk"),
    3: .same(proto: "challenge"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.esk) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.challenge) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 1)
    }
    if !self.esk.isEmpty {
      try visitor.visitSingularBytesField(value: self.esk, fieldNumber: 2)
    }
    if !self.challenge.isEmpty {
      try visitor.visitSingularBytesField(value: self.challenge, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2m_ServerHello, rhs: D2m_ServerHello) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.esk != rhs.esk {return false}
    if lhs.challenge != rhs.challenge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_ClientHello: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ClientHello"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "response"),
    3: .standard(proto: "device_id"),
    4: .standard(proto: "device_slots_exhausted_policy"),
    5: .standard(proto: "device_slot_expiration_policy"),
    7: .standard(proto: "expected_device_slot_state"),
    6: .standard(proto: "encrypted_device_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.version) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.response) }()
      case 3: try { try decoder.decodeSingularFixed64Field(value: &self.deviceID) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.deviceSlotsExhaustedPolicy) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.deviceSlotExpirationPolicy) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.encryptedDeviceInfo) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self._expectedDeviceSlotState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.version != 0 {
      try visitor.visitSingularUInt32Field(value: self.version, fieldNumber: 1)
    }
    if !self.response.isEmpty {
      try visitor.visitSingularBytesField(value: self.response, fieldNumber: 2)
    }
    if self.deviceID != 0 {
      try visitor.visitSingularFixed64Field(value: self.deviceID, fieldNumber: 3)
    }
    if self.deviceSlotsExhaustedPolicy != .reject {
      try visitor.visitSingularEnumField(value: self.deviceSlotsExhaustedPolicy, fieldNumber: 4)
    }
    if self.deviceSlotExpirationPolicy != .volatile {
      try visitor.visitSingularEnumField(value: self.deviceSlotExpirationPolicy, fieldNumber: 5)
    }
    if !self.encryptedDeviceInfo.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedDeviceInfo, fieldNumber: 6)
    }
    try { if let v = self._expectedDeviceSlotState {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2m_ClientHello, rhs: D2m_ClientHello) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.response != rhs.response {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.deviceSlotsExhaustedPolicy != rhs.deviceSlotsExhaustedPolicy {return false}
    if lhs.deviceSlotExpirationPolicy != rhs.deviceSlotExpirationPolicy {return false}
    if lhs._expectedDeviceSlotState != rhs._expectedDeviceSlotState {return false}
    if lhs.encryptedDeviceInfo != rhs.encryptedDeviceInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_ClientHello.DeviceSlotsExhaustedPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REJECT"),
    1: .same(proto: "DROP_LEAST_RECENT"),
  ]
}

extension D2m_ServerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ServerInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "current_time"),
    1: .standard(proto: "max_device_slots"),
    2: .standard(proto: "device_slot_state"),
    3: .standard(proto: "encrypted_shared_device_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.maxDeviceSlots) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.deviceSlotState) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.encryptedSharedDeviceData) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.currentTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxDeviceSlots != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxDeviceSlots, fieldNumber: 1)
    }
    if self.deviceSlotState != .new {
      try visitor.visitSingularEnumField(value: self.deviceSlotState, fieldNumber: 2)
    }
    if !self.encryptedSharedDeviceData.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedSharedDeviceData, fieldNumber: 3)
    }
    if self.currentTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.currentTime, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2m_ServerInfo, rhs: D2m_ServerInfo) -> Bool {
    if lhs.currentTime != rhs.currentTime {return false}
    if lhs.maxDeviceSlots != rhs.maxDeviceSlots {return false}
    if lhs.deviceSlotState != rhs.deviceSlotState {return false}
    if lhs.encryptedSharedDeviceData != rhs.encryptedSharedDeviceData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_ReflectionQueueDry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReflectionQueueDry"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2m_ReflectionQueueDry, rhs: D2m_ReflectionQueueDry) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_RolePromotedToLeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RolePromotedToLeader"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2m_RolePromotedToLeader, rhs: D2m_RolePromotedToLeader) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_GetDevicesInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetDevicesInfo"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2m_GetDevicesInfo, rhs: D2m_GetDevicesInfo) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_DevicesInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DevicesInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "augmented_device_info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufFixed64,D2m_DevicesInfo.AugmentedDeviceInfo>.self, value: &self.augmentedDeviceInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.augmentedDeviceInfo.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufFixed64,D2m_DevicesInfo.AugmentedDeviceInfo>.self, value: self.augmentedDeviceInfo, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2m_DevicesInfo, rhs: D2m_DevicesInfo) -> Bool {
    if lhs.augmentedDeviceInfo != rhs.augmentedDeviceInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_DevicesInfo.AugmentedDeviceInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = D2m_DevicesInfo.protoMessageName + ".AugmentedDeviceInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "encrypted_device_info"),
    2: .standard(proto: "last_login_at"),
    3: .standard(proto: "device_slot_expiration_policy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.encryptedDeviceInfo) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.lastLoginAt) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.deviceSlotExpirationPolicy) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.encryptedDeviceInfo.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedDeviceInfo, fieldNumber: 1)
    }
    if self.lastLoginAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.lastLoginAt, fieldNumber: 2)
    }
    if self.deviceSlotExpirationPolicy != .volatile {
      try visitor.visitSingularEnumField(value: self.deviceSlotExpirationPolicy, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2m_DevicesInfo.AugmentedDeviceInfo, rhs: D2m_DevicesInfo.AugmentedDeviceInfo) -> Bool {
    if lhs.encryptedDeviceInfo != rhs.encryptedDeviceInfo {return false}
    if lhs.lastLoginAt != rhs.lastLoginAt {return false}
    if lhs.deviceSlotExpirationPolicy != rhs.deviceSlotExpirationPolicy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_DropDevice: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DropDevice"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.deviceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.deviceID != 0 {
      try visitor.visitSingularFixed64Field(value: self.deviceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2m_DropDevice, rhs: D2m_DropDevice) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_DropDeviceAck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DropDeviceAck"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.deviceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.deviceID != 0 {
      try visitor.visitSingularFixed64Field(value: self.deviceID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2m_DropDeviceAck, rhs: D2m_DropDeviceAck) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_SetSharedDeviceData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SetSharedDeviceData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "encrypted_shared_device_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.encryptedSharedDeviceData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.encryptedSharedDeviceData.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedSharedDeviceData, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2m_SetSharedDeviceData, rhs: D2m_SetSharedDeviceData) -> Bool {
    if lhs.encryptedSharedDeviceData != rhs.encryptedSharedDeviceData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_BeginTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BeginTransaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "encrypted_scope"),
    2: .same(proto: "ttl"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.encryptedScope) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.ttl) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.encryptedScope.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedScope, fieldNumber: 1)
    }
    if self.ttl != 0 {
      try visitor.visitSingularUInt32Field(value: self.ttl, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2m_BeginTransaction, rhs: D2m_BeginTransaction) -> Bool {
    if lhs.encryptedScope != rhs.encryptedScope {return false}
    if lhs.ttl != rhs.ttl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_BeginTransactionAck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BeginTransactionAck"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2m_BeginTransactionAck, rhs: D2m_BeginTransactionAck) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_CommitTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommitTransaction"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2m_CommitTransaction, rhs: D2m_CommitTransaction) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_CommitTransactionAck: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommitTransactionAck"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2m_CommitTransactionAck, rhs: D2m_CommitTransactionAck) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_TransactionRejected: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionRejected"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
    2: .standard(proto: "encrypted_scope"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.encryptedScope) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.deviceID != 0 {
      try visitor.visitSingularFixed64Field(value: self.deviceID, fieldNumber: 1)
    }
    if !self.encryptedScope.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedScope, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2m_TransactionRejected, rhs: D2m_TransactionRejected) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.encryptedScope != rhs.encryptedScope {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension D2m_TransactionEnded: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TransactionEnded"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
    2: .standard(proto: "encrypted_scope"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.encryptedScope) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.deviceID != 0 {
      try visitor.visitSingularFixed64Field(value: self.deviceID, fieldNumber: 1)
    }
    if !self.encryptedScope.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedScope, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: D2m_TransactionEnded, rhs: D2m_TransactionEnded) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.encryptedScope != rhs.encryptedScope {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
