//  _____ _
// |_   _| |_  _ _ ___ ___ _ __  __ _
//   | | | ' \| '_/ -_) -_) '  \/ _` |_
//   |_| |_||_|_| \___\___|_|_|_\__,_(_)
//
// Threema iOS Client
// Copyright (c) 2020-2022 Threema GmbH
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License, version 3,
// as published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Visibility of a conversation.
enum Safe_ConversationVisibility: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Appears in the list of conversations
  case show // = 0

  /// Appears in the archived list of conversations
  case archive // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .show
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .show
    case 1: self = .archive
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .show: return 0
    case .archive: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Safe_ConversationVisibility: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_ConversationVisibility] = [
    .show,
    .archive,
  ]
}

#endif  // swift(>=4.2)

/// Category of a conversation.
enum Safe_ConversationCategory: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// No specific (default) category
  case `default` // = 0

  /// Protected conversation (*private chat*)
  case protected // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .default
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .default
    case 1: self = .protected
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .default: return 0
    case .protected: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Safe_ConversationCategory: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_ConversationCategory] = [
    .default,
    .protected,
  ]
}

#endif  // swift(>=4.2)

/// Threema Safe backup contents.
struct Safe_Backup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Version of the format
  /// References: `info.version`
  var version: UInt32 {
    get {return _storage._version}
    set {_uniqueStorage()._version = newValue}
  }

  /// Metadata about the device which created the backup
  /// References: `info.device`
  var device: String {
    get {return _storage._device}
    set {_uniqueStorage()._device = newValue}
  }

  /// The private key associated with the Threema ID
  /// References: `user.privatekey`
  var privateKey: Data {
    get {return _storage._privateKey}
    set {_uniqueStorage()._privateKey = newValue}
  }

  /// The user's profile
  /// Note: The data MUST be inlined!
  var userProfile: Safe_UserProfile {
    get {return _storage._userProfile ?? Safe_UserProfile()}
    set {_uniqueStorage()._userProfile = newValue}
  }
  /// Returns true if `userProfile` has been explicitly set.
  var hasUserProfile: Bool {return _storage._userProfile != nil}
  /// Clears the value of `userProfile`. Subsequent reads from it will return its default value.
  mutating func clearUserProfile() {_uniqueStorage()._userProfile = nil}

  /// Contacts
  /// References: `contacts[]`
  var contacts: [Safe_Contact] {
    get {return _storage._contacts}
    set {_uniqueStorage()._contacts = newValue}
  }

  /// Groups
  /// References: `groups[]`
  var groups: [Safe_Group] {
    get {return _storage._groups}
    set {_uniqueStorage()._groups = newValue}
  }

  /// Distribution lists
  /// References: `distributionlists[]`
  var distributionLists: [Safe_DistributionList] {
    get {return _storage._distributionLists}
    set {_uniqueStorage()._distributionLists = newValue}
  }

  /// App settings
  /// References: `settings`
  var settings: Safe_Settings {
    get {return _storage._settings ?? Safe_Settings()}
    set {_uniqueStorage()._settings = newValue}
  }
  /// Returns true if `settings` has been explicitly set.
  var hasSettings: Bool {return _storage._settings != nil}
  /// Clears the value of `settings`. Subsequent reads from it will return its default value.
  mutating func clearSettings() {_uniqueStorage()._settings = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// The user's profile.
struct Safe_UserProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Nickname
  /// References: `user.nickname`
  var nickname: String = String()

  /// Profile image
  /// References: `user.profilePic`
  var profileImage: Common_DeltaImage {
    get {return _profileImage ?? Common_DeltaImage()}
    set {_profileImage = newValue}
  }
  /// Returns true if `profileImage` has been explicitly set.
  var hasProfileImage: Bool {return self._profileImage != nil}
  /// Clears the value of `profileImage`. Subsequent reads from it will return its default value.
  mutating func clearProfileImage() {self._profileImage = nil}

  var profileImageSharePolicy: Safe_UserProfile.ProfileImageSharePolicy = .nobody

  /// Contact IDs the profile image may be shared with. Should only be filled
  /// when the `ProfileImageSharePolicy` is `ALLOW_LIST`.
  /// References: `user.profilePicRelease[]`
  var profileImageShareWith: [String] = []

  /// External entities linked with the identity
  /// References: `user.links[]`
  var identityLinks: [Safe_IdentityLink] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Profile image share policy
  /// References: `user.profilePicRelease[]`
  enum ProfileImageSharePolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Don't share
    case nobody // = 0

    /// Share with everyone
    case everyone // = 1

    /// Share with a limited amount of contacts explicitly listed
    case allowList // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .nobody
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .nobody
      case 1: self = .everyone
      case 2: self = .allowList
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .nobody: return 0
      case .everyone: return 1
      case .allowList: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _profileImage: Common_DeltaImage? = nil
}

#if swift(>=4.2)

extension Safe_UserProfile.ProfileImageSharePolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_UserProfile.ProfileImageSharePolicy] = [
    .nobody,
    .everyone,
    .allowList,
  ]
}

#endif  // swift(>=4.2)

/// Threema contact.
struct Safe_Contact {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Threema ID of the contact
  /// References: `contacts[].identity`
  var identity: String {
    get {return _storage._identity}
    set {_uniqueStorage()._identity = newValue}
  }

  /// Public key of the contact
  /// References: `contacts[].publickey`
  var publicKey: Data {
    get {return _storage._publicKey}
    set {_uniqueStorage()._publicKey = newValue}
  }

  /// Unix-ish timestamp in milliseconds when the contact has been created
  /// (added) locally.
  /// References: `contacts[].createdAt`
  var createdAt: UInt64 {
    get {return _storage._createdAt}
    set {_uniqueStorage()._createdAt = newValue}
  }

  var verificationLevel: Safe_Contact.VerificationLevel {
    get {return _storage._verificationLevel}
    set {_uniqueStorage()._verificationLevel = newValue}
  }

  var identityType: Safe_Contact.IdentityType {
    get {return _storage._identityType}
    set {_uniqueStorage()._identityType = newValue}
  }

  var displayPolicy: Safe_Contact.DisplayPolicy {
    get {return _storage._displayPolicy}
    set {_uniqueStorage()._displayPolicy = newValue}
  }

  /// Conversation category of the contact
  /// References: `contacts[].private`
  var conversationCategory: Safe_ConversationCategory {
    get {return _storage._conversationCategory}
    set {_uniqueStorage()._conversationCategory = newValue}
  }

  /// Conversation visbility of the contact
  var conversationVisibility: Safe_ConversationVisibility {
    get {return _storage._conversationVisibility}
    set {_uniqueStorage()._conversationVisibility = newValue}
  }

  /// First name of the contact
  /// References: `contacts[].firstname`
  var firstName: OneOf_FirstName? {
    get {return _storage._firstName}
    set {_uniqueStorage()._firstName = newValue}
  }

  var firstNameValue: String {
    get {
      if case .firstNameValue(let v)? = _storage._firstName {return v}
      return String()
    }
    set {_uniqueStorage()._firstName = .firstNameValue(newValue)}
  }

  /// Last name of the contact
  /// References: `contacts[].lastname`
  var lastName: OneOf_LastName? {
    get {return _storage._lastName}
    set {_uniqueStorage()._lastName = newValue}
  }

  var lastNameValue: String {
    get {
      if case .lastNameValue(let v)? = _storage._lastName {return v}
      return String()
    }
    set {_uniqueStorage()._lastName = .lastNameValue(newValue)}
  }

  /// Nickname of the contact (without `~` prefix)
  /// References: `contacts[].nickname`
  var nickname: OneOf_Nickname? {
    get {return _storage._nickname}
    set {_uniqueStorage()._nickname = newValue}
  }

  var nicknameValue: String {
    get {
      if case .nicknameValue(let v)? = _storage._nickname {return v}
      return String()
    }
    set {_uniqueStorage()._nickname = .nicknameValue(newValue)}
  }

  /// Profile image as received from the contact
  var profileImage: Common_DeltaImage {
    get {return _storage._profileImage ?? Common_DeltaImage()}
    set {_uniqueStorage()._profileImage = newValue}
  }
  /// Returns true if `profileImage` has been explicitly set.
  var hasProfileImage: Bool {return _storage._profileImage != nil}
  /// Clears the value of `profileImage`. Subsequent reads from it will return its default value.
  mutating func clearProfileImage() {_uniqueStorage()._profileImage = nil}

  /// Custom profile image set by the user
  var customProfileImage: Common_DeltaImage {
    get {return _storage._customProfileImage ?? Common_DeltaImage()}
    set {_uniqueStorage()._customProfileImage = newValue}
  }
  /// Returns true if `customProfileImage` has been explicitly set.
  var hasCustomProfileImage: Bool {return _storage._customProfileImage != nil}
  /// Clears the value of `customProfileImage`. Subsequent reads from it will return its default value.
  mutating func clearCustomProfileImage() {_uniqueStorage()._customProfileImage = nil}

  var syncState: Safe_Contact.SyncState {
    get {return _storage._syncState}
    set {_uniqueStorage()._syncState = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// First name of the contact
  /// References: `contacts[].firstname`
  enum OneOf_FirstName: Equatable {
    case firstNameValue(String)

  #if !swift(>=4.1)
    static func ==(lhs: Safe_Contact.OneOf_FirstName, rhs: Safe_Contact.OneOf_FirstName) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.firstNameValue, .firstNameValue): return {
        guard case .firstNameValue(let l) = lhs, case .firstNameValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// Last name of the contact
  /// References: `contacts[].lastname`
  enum OneOf_LastName: Equatable {
    case lastNameValue(String)

  #if !swift(>=4.1)
    static func ==(lhs: Safe_Contact.OneOf_LastName, rhs: Safe_Contact.OneOf_LastName) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.lastNameValue, .lastNameValue): return {
        guard case .lastNameValue(let l) = lhs, case .lastNameValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// Nickname of the contact (without `~` prefix)
  /// References: `contacts[].nickname`
  enum OneOf_Nickname: Equatable {
    case nicknameValue(String)

  #if !swift(>=4.1)
    static func ==(lhs: Safe_Contact.OneOf_Nickname, rhs: Safe_Contact.OneOf_Nickname) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.nicknameValue, .nicknameValue): return {
        guard case .nicknameValue(let l) = lhs, case .nicknameValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  /// Verification level of the contact
  /// References: `contacts[].verification`
  enum VerificationLevel: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Unverified, public key has been obtained from the server
    case unverified // = 0

    /// Verified with one of the account links via the server, or the contact
    /// has been obtained via the Work API.
    case serverVerified // = 1

    /// Verified, public key has been obtained via a secure channel
    case fullyVerified // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unverified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unverified
      case 1: self = .serverVerified
      case 2: self = .fullyVerified
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unverified: return 0
      case .serverVerified: return 1
      case .fullyVerified: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Identity type of the contact
  /// References: `contacts[].workVerified`
  enum IdentityType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Regular contact (uses the regular Threema app)
    case regular // = 0

    /// Work contact (uses the Threema work app)
    case work // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .regular
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .regular
      case 1: self = .work
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .regular: return 0
      case .work: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Display policy for the contact
  /// References: `contacts[].hidden`
  enum DisplayPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Show contact
    case show // = 0

    /// Hide contact (e.g. group contact not explicitly added)
    case hide // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .show
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .show
      case 1: self = .hide
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .show: return 0
      case .hide: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Contact synchronisation state
  /// Note: These states are strict monotonic.
  enum SyncState: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// The contact data has not been imported and has not been edited by the
    /// user either.
    case initial // = 0

    /// The contact data has been imported (e.g. via a local address book and an
    /// identity link). In this state, subsequent contact synchronisations must
    /// not alter the contact's data.
    case imported // = 1

    /// The contact data has been edited by the user. In this state, subsequent
    /// contact synchronisations must not alter the contact's data.
    case custom // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .initial
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .initial
      case 1: self = .imported
      case 2: self = .custom
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .initial: return 0
      case .imported: return 1
      case .custom: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Safe_Contact.VerificationLevel: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_Contact.VerificationLevel] = [
    .unverified,
    .serverVerified,
    .fullyVerified,
  ]
}

extension Safe_Contact.IdentityType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_Contact.IdentityType] = [
    .regular,
    .work,
  ]
}

extension Safe_Contact.DisplayPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_Contact.DisplayPolicy] = [
    .show,
    .hide,
  ]
}

extension Safe_Contact.SyncState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_Contact.SyncState] = [
    .initial,
    .imported,
    .custom,
  ]
}

#endif  // swift(>=4.2)

/// Threema contacts associated to a group.
struct Safe_Group {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique group identity
  /// References: `groups[].id` and `groups[].creator`
  var groupIdentity: Common_GroupIdentity {
    get {return _groupIdentity ?? Common_GroupIdentity()}
    set {_groupIdentity = newValue}
  }
  /// Returns true if `groupIdentity` has been explicitly set.
  var hasGroupIdentity: Bool {return self._groupIdentity != nil}
  /// Clears the value of `groupIdentity`. Subsequent reads from it will return its default value.
  mutating func clearGroupIdentity() {self._groupIdentity = nil}

  /// Name of the group
  /// References: `groups[].groupname`
  var name: String = String()

  /// Unix-ish timestamp in milliseconds when the group has been created locally
  /// References: `groups[].createdAt`
  var createdAt: UInt64 = 0

  /// Conversation category of the group
  /// References: `groups[].private`
  var conversationCategory: Safe_ConversationCategory = .default

  /// Conversation visbility of the group
  var conversationVisibility: Safe_ConversationVisibility = .show

  var userState: Safe_Group.UserState = .member

  /// Group's profile image as received from the group's administrator
  var profileImage: Common_Image {
    get {return _profileImage ?? Common_Image()}
    set {_profileImage = newValue}
  }
  /// Returns true if `profileImage` has been explicitly set.
  var hasProfileImage: Bool {return self._profileImage != nil}
  /// Clears the value of `profileImage`. Subsequent reads from it will return its default value.
  mutating func clearProfileImage() {self._profileImage = nil}

  /// Group members (**NOT** including the user itself)
  /// References: `groups[].members`
  var memberIdentities: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The user's state within the group
  /// References: `groups[].deleted`
  enum UserState: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// The user is a member (or an admin) of the group
    case member // = 0

    /// The user has been kicked from the group
    case kicked // = 1

    /// The user left the group
    case left // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .member
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .member
      case 1: self = .kicked
      case 2: self = .left
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .member: return 0
      case .kicked: return 1
      case .left: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _groupIdentity: Common_GroupIdentity? = nil
  fileprivate var _profileImage: Common_Image? = nil
}

#if swift(>=4.2)

extension Safe_Group.UserState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_Group.UserState] = [
    .member,
    .kicked,
    .left,
  ]
}

#endif  // swift(>=4.2)

/// Threema contacts associated to a distribution list.
struct Safe_DistributionList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique ID of the distribution list
  var distributionListID: UInt64 = 0

  /// Name of the distribution list
  /// References: `distributionlists[].name`
  var name: String = String()

  /// Unix-ish timestamp in milliseconds when the group has been created
  /// References: `distributionlists[].createdAt`
  var createdAt: UInt64 = 0

  /// Conversation category of the distribution list
  /// References: `distributionlists[].private`
  var conversationCategory: Safe_ConversationCategory = .default

  /// Conversation visbility of the distribution list
  var conversationVisibility: Safe_ConversationVisibility = .show

  /// Distribution list members
  /// References: `distributionlists[].members`
  var memberIdentities: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// App settings
struct Safe_Settings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var contactSyncPolicy: Safe_Settings.ContactSyncPolicy = .notSynced

  var unknownContactPolicy: Safe_Settings.UnknownContactPolicy = .allowUnknown

  var readMessagePolicy: Safe_Settings.ReadMessagePolicy = .sendReadReceipt

  var composeMessagePolicy: Safe_Settings.ComposeMessagePolicy = .sendTypingIndicator

  var callPolicy: Safe_Settings.CallPolicy = .allowCall

  var callConnectionPolity: Safe_Settings.CallConnectionPolicy = .allowDirect

  var screenshotPolicy: Safe_Settings.ScreenshotPolicy = .allowScreenshot

  var keyboardDataCollectionPolicy: Safe_Settings.KeyboardDataCollectionPolicy = .allowDataCollection

  /// List of Threema IDs whose messages are blocked
  /// References: `settings.blockedContacts[]`
  var blockedIdentities: [String] = []

  /// Threema IDs to be excluded when syncing
  /// References: `settings.syncExcludedIds[]`
  var excludeFromSyncIdentities: [String] = []

  /// List of recently used emojis, where the most recently used Emoji comes
  /// first.
  /// References: `settings.recentEmojis[]`
  var recentEmojis: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Contact synchronisation policy
  /// References: `settings.syncContacts`
  enum ContactSyncPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Not synced
    case notSynced // = 0

    /// Synced
    case sync // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .notSynced
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .notSynced
      case 1: self = .sync
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .notSynced: return 0
      case .sync: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Unknown contacts policy
  /// References: `settings.blockUnknown`
  enum UnknownContactPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Allowed to contact the user
    case allowUnknown // = 0

    /// Will be blocked by the user
    case blockUnknown // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowUnknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowUnknown
      case 1: self = .blockUnknown
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowUnknown: return 0
      case .blockUnknown: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Read message policy (when an unread message has been read)
  /// References: `settings.readReceipts`
  enum ReadMessagePolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Send *read* receipt when an unread message has been read
    case sendReadReceipt // = 0

    /// Don't send *read* receipts
    case ignoreRead // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .sendReadReceipt
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .sendReadReceipt
      case 1: self = .ignoreRead
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .sendReadReceipt: return 0
      case .ignoreRead: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Compose message policy
  /// References: `settings.sendTyping`
  enum ComposeMessagePolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Send *typing* indicator when a message is being composed
    case sendTypingIndicator // = 0

    /// Don't send *typing* indicators
    case ignoreCompose // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .sendTypingIndicator
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .sendTypingIndicator
      case 1: self = .ignoreCompose
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .sendTypingIndicator: return 0
      case .ignoreCompose: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Threema Call policy
  /// References: `settings.threemaCalls`
  enum CallPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Allow creating/receiving Threema Calls
    case allowCall // = 0

    /// Denied from creating/receiving any Threema Calls
    case denyCall // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowCall
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowCall
      case 1: self = .denyCall
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowCall: return 0
      case .denyCall: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Threema Call connection policy
  /// References: `settings.relayThreemaCalls`
  enum CallConnectionPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Allow direct (peer-to-peer) connections for Threema Calls
    case allowDirect // = 0

    /// Require relayed connections for Threema Calls
    case requireRelay // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowDirect
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowDirect
      case 1: self = .requireRelay
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowDirect: return 0
      case .requireRelay: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Screenshot policy
  /// References: `settings.disableScreenshots`
  enum ScreenshotPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Allow taking screenshots
    case allowScreenshot // = 0

    /// Deny taking screenshots, if possible
    case denyScreenshot // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowScreenshot
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowScreenshot
      case 1: self = .denyScreenshot
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowScreenshot: return 0
      case .denyScreenshot: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Keyboard data collection policy (e.g. for personalised suggestions)
  /// References: `settings.incognitoKeyboard`
  enum KeyboardDataCollectionPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Allow keyboard input data to be collected
    case allowDataCollection // = 0

    /// Deny collecting of keyboard input data
    case denyDataCollection // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowDataCollection
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowDataCollection
      case 1: self = .denyDataCollection
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowDataCollection: return 0
      case .denyDataCollection: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Safe_Settings.ContactSyncPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_Settings.ContactSyncPolicy] = [
    .notSynced,
    .sync,
  ]
}

extension Safe_Settings.UnknownContactPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_Settings.UnknownContactPolicy] = [
    .allowUnknown,
    .blockUnknown,
  ]
}

extension Safe_Settings.ReadMessagePolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_Settings.ReadMessagePolicy] = [
    .sendReadReceipt,
    .ignoreRead,
  ]
}

extension Safe_Settings.ComposeMessagePolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_Settings.ComposeMessagePolicy] = [
    .sendTypingIndicator,
    .ignoreCompose,
  ]
}

extension Safe_Settings.CallPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_Settings.CallPolicy] = [
    .allowCall,
    .denyCall,
  ]
}

extension Safe_Settings.CallConnectionPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_Settings.CallConnectionPolicy] = [
    .allowDirect,
    .requireRelay,
  ]
}

extension Safe_Settings.ScreenshotPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_Settings.ScreenshotPolicy] = [
    .allowScreenshot,
    .denyScreenshot,
  ]
}

extension Safe_Settings.KeyboardDataCollectionPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Safe_Settings.KeyboardDataCollectionPolicy] = [
    .allowDataCollection,
    .denyDataCollection,
  ]
}

#endif  // swift(>=4.2)

/// Threema ID link.
struct Safe_IdentityLink {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identity link type
  /// References: `user.links[].type`, `user.links[].value`
  var type: Safe_IdentityLink.OneOf_Type? = nil

  /// Linked with a verified telephone number (E.164 format without leading
  /// `+`)
  var phoneNumber: String {
    get {
      if case .phoneNumber(let v)? = type {return v}
      return String()
    }
    set {type = .phoneNumber(newValue)}
  }

  /// Linked with a verified email address
  var email: String {
    get {
      if case .email(let v)? = type {return v}
      return String()
    }
    set {type = .email(newValue)}
  }

  /// Identity link description
  /// References: `user.links[].name`
  var description_p: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Identity link type
  /// References: `user.links[].type`, `user.links[].value`
  enum OneOf_Type: Equatable {
    /// Linked with a verified telephone number (E.164 format without leading
    /// `+`)
    case phoneNumber(String)
    /// Linked with a verified email address
    case email(String)

  #if !swift(>=4.1)
    static func ==(lhs: Safe_IdentityLink.OneOf_Type, rhs: Safe_IdentityLink.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.phoneNumber, .phoneNumber): return {
        guard case .phoneNumber(let l) = lhs, case .phoneNumber(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.email, .email): return {
        guard case .email(let l) = lhs, case .email(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "safe"

extension Safe_ConversationVisibility: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SHOW"),
    1: .same(proto: "ARCHIVE"),
  ]
}

extension Safe_ConversationCategory: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "PROTECTED"),
  ]
}

extension Safe_Backup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Backup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .same(proto: "device"),
    3: .standard(proto: "private_key"),
    4: .standard(proto: "user_profile"),
    5: .same(proto: "contacts"),
    6: .same(proto: "groups"),
    7: .standard(proto: "distribution_lists"),
    8: .same(proto: "settings"),
  ]

  fileprivate class _StorageClass {
    var _version: UInt32 = 0
    var _device: String = String()
    var _privateKey: Data = Data()
    var _userProfile: Safe_UserProfile? = nil
    var _contacts: [Safe_Contact] = []
    var _groups: [Safe_Group] = []
    var _distributionLists: [Safe_DistributionList] = []
    var _settings: Safe_Settings? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _version = source._version
      _device = source._device
      _privateKey = source._privateKey
      _userProfile = source._userProfile
      _contacts = source._contacts
      _groups = source._groups
      _distributionLists = source._distributionLists
      _settings = source._settings
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularUInt32Field(value: &_storage._version) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._device) }()
        case 3: try { try decoder.decodeSingularBytesField(value: &_storage._privateKey) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._userProfile) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._contacts) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._groups) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._distributionLists) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._settings) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._version != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._version, fieldNumber: 1)
      }
      if !_storage._device.isEmpty {
        try visitor.visitSingularStringField(value: _storage._device, fieldNumber: 2)
      }
      if !_storage._privateKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._privateKey, fieldNumber: 3)
      }
      if let v = _storage._userProfile {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if !_storage._contacts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._contacts, fieldNumber: 5)
      }
      if !_storage._groups.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._groups, fieldNumber: 6)
      }
      if !_storage._distributionLists.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._distributionLists, fieldNumber: 7)
      }
      if let v = _storage._settings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Safe_Backup, rhs: Safe_Backup) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._version != rhs_storage._version {return false}
        if _storage._device != rhs_storage._device {return false}
        if _storage._privateKey != rhs_storage._privateKey {return false}
        if _storage._userProfile != rhs_storage._userProfile {return false}
        if _storage._contacts != rhs_storage._contacts {return false}
        if _storage._groups != rhs_storage._groups {return false}
        if _storage._distributionLists != rhs_storage._distributionLists {return false}
        if _storage._settings != rhs_storage._settings {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Safe_UserProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserProfile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nickname"),
    2: .standard(proto: "profile_image"),
    3: .standard(proto: "profile_image_share_policy"),
    4: .standard(proto: "profile_image_share_with"),
    5: .standard(proto: "identity_links"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.nickname) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._profileImage) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.profileImageSharePolicy) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.profileImageShareWith) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.identityLinks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nickname.isEmpty {
      try visitor.visitSingularStringField(value: self.nickname, fieldNumber: 1)
    }
    if let v = self._profileImage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.profileImageSharePolicy != .nobody {
      try visitor.visitSingularEnumField(value: self.profileImageSharePolicy, fieldNumber: 3)
    }
    if !self.profileImageShareWith.isEmpty {
      try visitor.visitRepeatedStringField(value: self.profileImageShareWith, fieldNumber: 4)
    }
    if !self.identityLinks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.identityLinks, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Safe_UserProfile, rhs: Safe_UserProfile) -> Bool {
    if lhs.nickname != rhs.nickname {return false}
    if lhs._profileImage != rhs._profileImage {return false}
    if lhs.profileImageSharePolicy != rhs.profileImageSharePolicy {return false}
    if lhs.profileImageShareWith != rhs.profileImageShareWith {return false}
    if lhs.identityLinks != rhs.identityLinks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Safe_UserProfile.ProfileImageSharePolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOBODY"),
    1: .same(proto: "EVERYONE"),
    2: .same(proto: "ALLOW_LIST"),
  ]
}

extension Safe_Contact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Contact"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identity"),
    2: .standard(proto: "public_key"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "verification_level"),
    5: .standard(proto: "identity_type"),
    6: .standard(proto: "display_policy"),
    7: .standard(proto: "conversation_category"),
    8: .standard(proto: "conversation_visibility"),
    9: .standard(proto: "first_name_value"),
    10: .standard(proto: "last_name_value"),
    11: .standard(proto: "nickname_value"),
    12: .standard(proto: "profile_image"),
    13: .standard(proto: "custom_profile_image"),
    14: .standard(proto: "sync_state"),
  ]

  fileprivate class _StorageClass {
    var _identity: String = String()
    var _publicKey: Data = Data()
    var _createdAt: UInt64 = 0
    var _verificationLevel: Safe_Contact.VerificationLevel = .unverified
    var _identityType: Safe_Contact.IdentityType = .regular
    var _displayPolicy: Safe_Contact.DisplayPolicy = .show
    var _conversationCategory: Safe_ConversationCategory = .default
    var _conversationVisibility: Safe_ConversationVisibility = .show
    var _firstName: Safe_Contact.OneOf_FirstName?
    var _lastName: Safe_Contact.OneOf_LastName?
    var _nickname: Safe_Contact.OneOf_Nickname?
    var _profileImage: Common_DeltaImage? = nil
    var _customProfileImage: Common_DeltaImage? = nil
    var _syncState: Safe_Contact.SyncState = .initial

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _identity = source._identity
      _publicKey = source._publicKey
      _createdAt = source._createdAt
      _verificationLevel = source._verificationLevel
      _identityType = source._identityType
      _displayPolicy = source._displayPolicy
      _conversationCategory = source._conversationCategory
      _conversationVisibility = source._conversationVisibility
      _firstName = source._firstName
      _lastName = source._lastName
      _nickname = source._nickname
      _profileImage = source._profileImage
      _customProfileImage = source._customProfileImage
      _syncState = source._syncState
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._identity) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._publicKey) }()
        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._createdAt) }()
        case 4: try { try decoder.decodeSingularEnumField(value: &_storage._verificationLevel) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._identityType) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._displayPolicy) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._conversationCategory) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._conversationVisibility) }()
        case 9: try {
          if _storage._firstName != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._firstName = .firstNameValue(v)}
        }()
        case 10: try {
          if _storage._lastName != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._lastName = .lastNameValue(v)}
        }()
        case 11: try {
          if _storage._nickname != nil {try decoder.handleConflictingOneOf()}
          var v: String?
          try decoder.decodeSingularStringField(value: &v)
          if let v = v {_storage._nickname = .nicknameValue(v)}
        }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._profileImage) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._customProfileImage) }()
        case 14: try { try decoder.decodeSingularEnumField(value: &_storage._syncState) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._identity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._identity, fieldNumber: 1)
      }
      if !_storage._publicKey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._publicKey, fieldNumber: 2)
      }
      if _storage._createdAt != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._createdAt, fieldNumber: 3)
      }
      if _storage._verificationLevel != .unverified {
        try visitor.visitSingularEnumField(value: _storage._verificationLevel, fieldNumber: 4)
      }
      if _storage._identityType != .regular {
        try visitor.visitSingularEnumField(value: _storage._identityType, fieldNumber: 5)
      }
      if _storage._displayPolicy != .show {
        try visitor.visitSingularEnumField(value: _storage._displayPolicy, fieldNumber: 6)
      }
      if _storage._conversationCategory != .default {
        try visitor.visitSingularEnumField(value: _storage._conversationCategory, fieldNumber: 7)
      }
      if _storage._conversationVisibility != .show {
        try visitor.visitSingularEnumField(value: _storage._conversationVisibility, fieldNumber: 8)
      }
      if case .firstNameValue(let v)? = _storage._firstName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      }
      if case .lastNameValue(let v)? = _storage._lastName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 10)
      }
      if case .nicknameValue(let v)? = _storage._nickname {
        try visitor.visitSingularStringField(value: v, fieldNumber: 11)
      }
      if let v = _storage._profileImage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }
      if let v = _storage._customProfileImage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }
      if _storage._syncState != .initial {
        try visitor.visitSingularEnumField(value: _storage._syncState, fieldNumber: 14)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Safe_Contact, rhs: Safe_Contact) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._identity != rhs_storage._identity {return false}
        if _storage._publicKey != rhs_storage._publicKey {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._verificationLevel != rhs_storage._verificationLevel {return false}
        if _storage._identityType != rhs_storage._identityType {return false}
        if _storage._displayPolicy != rhs_storage._displayPolicy {return false}
        if _storage._conversationCategory != rhs_storage._conversationCategory {return false}
        if _storage._conversationVisibility != rhs_storage._conversationVisibility {return false}
        if _storage._firstName != rhs_storage._firstName {return false}
        if _storage._lastName != rhs_storage._lastName {return false}
        if _storage._nickname != rhs_storage._nickname {return false}
        if _storage._profileImage != rhs_storage._profileImage {return false}
        if _storage._customProfileImage != rhs_storage._customProfileImage {return false}
        if _storage._syncState != rhs_storage._syncState {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Safe_Contact.VerificationLevel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNVERIFIED"),
    1: .same(proto: "SERVER_VERIFIED"),
    2: .same(proto: "FULLY_VERIFIED"),
  ]
}

extension Safe_Contact.IdentityType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REGULAR"),
    1: .same(proto: "WORK"),
  ]
}

extension Safe_Contact.DisplayPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SHOW"),
    1: .same(proto: "HIDE"),
  ]
}

extension Safe_Contact.SyncState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INITIAL"),
    1: .same(proto: "IMPORTED"),
    2: .same(proto: "CUSTOM"),
  ]
}

extension Safe_Group: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Group"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_identity"),
    2: .same(proto: "name"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "conversation_category"),
    5: .standard(proto: "conversation_visibility"),
    6: .standard(proto: "user_state"),
    7: .standard(proto: "profile_image"),
    8: .standard(proto: "member_identities"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._groupIdentity) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.createdAt) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.conversationCategory) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.conversationVisibility) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.userState) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._profileImage) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.memberIdentities) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._groupIdentity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.createdAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdAt, fieldNumber: 3)
    }
    if self.conversationCategory != .default {
      try visitor.visitSingularEnumField(value: self.conversationCategory, fieldNumber: 4)
    }
    if self.conversationVisibility != .show {
      try visitor.visitSingularEnumField(value: self.conversationVisibility, fieldNumber: 5)
    }
    if self.userState != .member {
      try visitor.visitSingularEnumField(value: self.userState, fieldNumber: 6)
    }
    if let v = self._profileImage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if !self.memberIdentities.isEmpty {
      try visitor.visitRepeatedStringField(value: self.memberIdentities, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Safe_Group, rhs: Safe_Group) -> Bool {
    if lhs._groupIdentity != rhs._groupIdentity {return false}
    if lhs.name != rhs.name {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.conversationCategory != rhs.conversationCategory {return false}
    if lhs.conversationVisibility != rhs.conversationVisibility {return false}
    if lhs.userState != rhs.userState {return false}
    if lhs._profileImage != rhs._profileImage {return false}
    if lhs.memberIdentities != rhs.memberIdentities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Safe_Group.UserState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MEMBER"),
    1: .same(proto: "KICKED"),
    2: .same(proto: "LEFT"),
  ]
}

extension Safe_DistributionList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DistributionList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "distribution_list_id"),
    2: .same(proto: "name"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "conversation_category"),
    5: .standard(proto: "conversation_visibility"),
    6: .standard(proto: "member_identities"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.distributionListID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.createdAt) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.conversationCategory) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.conversationVisibility) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.memberIdentities) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.distributionListID != 0 {
      try visitor.visitSingularFixed64Field(value: self.distributionListID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.createdAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdAt, fieldNumber: 3)
    }
    if self.conversationCategory != .default {
      try visitor.visitSingularEnumField(value: self.conversationCategory, fieldNumber: 4)
    }
    if self.conversationVisibility != .show {
      try visitor.visitSingularEnumField(value: self.conversationVisibility, fieldNumber: 5)
    }
    if !self.memberIdentities.isEmpty {
      try visitor.visitRepeatedStringField(value: self.memberIdentities, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Safe_DistributionList, rhs: Safe_DistributionList) -> Bool {
    if lhs.distributionListID != rhs.distributionListID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.conversationCategory != rhs.conversationCategory {return false}
    if lhs.conversationVisibility != rhs.conversationVisibility {return false}
    if lhs.memberIdentities != rhs.memberIdentities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Safe_Settings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Settings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contact_sync_policy"),
    2: .standard(proto: "unknown_contact_policy"),
    3: .standard(proto: "read_message_policy"),
    4: .standard(proto: "compose_message_policy"),
    5: .standard(proto: "call_policy"),
    6: .standard(proto: "call_connection_polity"),
    7: .standard(proto: "screenshot_policy"),
    8: .standard(proto: "keyboard_data_collection_policy"),
    9: .standard(proto: "blocked_identities"),
    10: .standard(proto: "exclude_from_sync_identities"),
    11: .standard(proto: "recent_emojis"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.contactSyncPolicy) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.unknownContactPolicy) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.readMessagePolicy) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.composeMessagePolicy) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.callPolicy) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.callConnectionPolity) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.screenshotPolicy) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.keyboardDataCollectionPolicy) }()
      case 9: try { try decoder.decodeRepeatedStringField(value: &self.blockedIdentities) }()
      case 10: try { try decoder.decodeRepeatedStringField(value: &self.excludeFromSyncIdentities) }()
      case 11: try { try decoder.decodeRepeatedStringField(value: &self.recentEmojis) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.contactSyncPolicy != .notSynced {
      try visitor.visitSingularEnumField(value: self.contactSyncPolicy, fieldNumber: 1)
    }
    if self.unknownContactPolicy != .allowUnknown {
      try visitor.visitSingularEnumField(value: self.unknownContactPolicy, fieldNumber: 2)
    }
    if self.readMessagePolicy != .sendReadReceipt {
      try visitor.visitSingularEnumField(value: self.readMessagePolicy, fieldNumber: 3)
    }
    if self.composeMessagePolicy != .sendTypingIndicator {
      try visitor.visitSingularEnumField(value: self.composeMessagePolicy, fieldNumber: 4)
    }
    if self.callPolicy != .allowCall {
      try visitor.visitSingularEnumField(value: self.callPolicy, fieldNumber: 5)
    }
    if self.callConnectionPolity != .allowDirect {
      try visitor.visitSingularEnumField(value: self.callConnectionPolity, fieldNumber: 6)
    }
    if self.screenshotPolicy != .allowScreenshot {
      try visitor.visitSingularEnumField(value: self.screenshotPolicy, fieldNumber: 7)
    }
    if self.keyboardDataCollectionPolicy != .allowDataCollection {
      try visitor.visitSingularEnumField(value: self.keyboardDataCollectionPolicy, fieldNumber: 8)
    }
    if !self.blockedIdentities.isEmpty {
      try visitor.visitRepeatedStringField(value: self.blockedIdentities, fieldNumber: 9)
    }
    if !self.excludeFromSyncIdentities.isEmpty {
      try visitor.visitRepeatedStringField(value: self.excludeFromSyncIdentities, fieldNumber: 10)
    }
    if !self.recentEmojis.isEmpty {
      try visitor.visitRepeatedStringField(value: self.recentEmojis, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Safe_Settings, rhs: Safe_Settings) -> Bool {
    if lhs.contactSyncPolicy != rhs.contactSyncPolicy {return false}
    if lhs.unknownContactPolicy != rhs.unknownContactPolicy {return false}
    if lhs.readMessagePolicy != rhs.readMessagePolicy {return false}
    if lhs.composeMessagePolicy != rhs.composeMessagePolicy {return false}
    if lhs.callPolicy != rhs.callPolicy {return false}
    if lhs.callConnectionPolity != rhs.callConnectionPolity {return false}
    if lhs.screenshotPolicy != rhs.screenshotPolicy {return false}
    if lhs.keyboardDataCollectionPolicy != rhs.keyboardDataCollectionPolicy {return false}
    if lhs.blockedIdentities != rhs.blockedIdentities {return false}
    if lhs.excludeFromSyncIdentities != rhs.excludeFromSyncIdentities {return false}
    if lhs.recentEmojis != rhs.recentEmojis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Safe_Settings.ContactSyncPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOT_SYNCED"),
    1: .same(proto: "SYNC"),
  ]
}

extension Safe_Settings.UnknownContactPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_UNKNOWN"),
    1: .same(proto: "BLOCK_UNKNOWN"),
  ]
}

extension Safe_Settings.ReadMessagePolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SEND_READ_RECEIPT"),
    1: .same(proto: "IGNORE_READ"),
  ]
}

extension Safe_Settings.ComposeMessagePolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SEND_TYPING_INDICATOR"),
    1: .same(proto: "IGNORE_COMPOSE"),
  ]
}

extension Safe_Settings.CallPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_CALL"),
    1: .same(proto: "DENY_CALL"),
  ]
}

extension Safe_Settings.CallConnectionPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_DIRECT"),
    1: .same(proto: "REQUIRE_RELAY"),
  ]
}

extension Safe_Settings.ScreenshotPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_SCREENSHOT"),
    1: .same(proto: "DENY_SCREENSHOT"),
  ]
}

extension Safe_Settings.KeyboardDataCollectionPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_DATA_COLLECTION"),
    1: .same(proto: "DENY_DATA_COLLECTION"),
  ]
}

extension Safe_IdentityLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IdentityLink"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "phone_number"),
    2: .same(proto: "email"),
    3: .same(proto: "description"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.type != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.type = .phoneNumber(v)}
      }()
      case 2: try {
        if self.type != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.type = .email(v)}
      }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.type {
    case .phoneNumber?: try {
      guard case .phoneNumber(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .email?: try {
      guard case .email(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Safe_IdentityLink, rhs: Safe_IdentityLink) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
