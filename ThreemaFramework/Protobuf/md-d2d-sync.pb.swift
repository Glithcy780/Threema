// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: md-d2d-sync.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// ## Data Synchronisation Messages
//
// All strings are UTF-8 encoded.
//
// ### General Information
//
// When creating a sync message, only provide fields which are required and
// fields whose values have changed (i.e. delta updates). Fields that are
// required will be explicitly marked. For any other field within a sync
// message, assume that it is optional.
//
// When receiving a sync message, only handle fields whose values have been
// provided. As a rule of thumb, if a field is not present it means that the
// value has not changed.
//
// If more specific rules are needed in order to handle a field correctly,
// a description will be provided for the specific field.
//
// ### Validation
//
// A sync message should be validated by the following general rules:
//
// - Strictly validate enums, i.e. unknown values are not allowed and no
//   silent fallbacks are allowed.
// - Empty strings/lists have a different semantic than an omitted string/list.
//   The field should have a concise description on whether emptiness is
//   allowed, and, if so, the meaning of _empty_.
// - Follow the description of each field for more specific validation.
//
// If any of these rules is violated, the message should be discarded and logged
// as an error (but still acknowledged, if necessary).

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// _Read_ receipt policy (when an unread message has been read)
enum Sync_ReadReceiptPolicy: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Send _read_ receipt when an unread message has been read
  case sendReadReceipt // = 0

  /// Don't send _read_ receipts
  case dontSendReadReceipt // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .sendReadReceipt
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sendReadReceipt
    case 1: self = .dontSendReadReceipt
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .sendReadReceipt: return 0
    case .dontSendReadReceipt: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sync_ReadReceiptPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_ReadReceiptPolicy] = [
    .sendReadReceipt,
    .dontSendReadReceipt,
  ]
}

#endif  // swift(>=4.2)

/// Typing indicator policy (signal _currently typing_)
enum Sync_TypingIndicatorPolicy: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Send _typing_ indicator when a message is being composed
  case sendTypingIndicator // = 0

  /// Don't send _typing_ indicators
  case dontSendTypingIndicator // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .sendTypingIndicator
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sendTypingIndicator
    case 1: self = .dontSendTypingIndicator
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .sendTypingIndicator: return 0
    case .dontSendTypingIndicator: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sync_TypingIndicatorPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_TypingIndicatorPolicy] = [
    .sendTypingIndicator,
    .dontSendTypingIndicator,
  ]
}

#endif  // swift(>=4.2)

/// Notificatoun sound policy.
enum Sync_NotificationSoundPolicy: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Do not emit a sound when notifying of a _conversation_ message.
  case muted // = 0
  case UNRECOGNIZED(Int)

  init() {
    self = .muted
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .muted
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .muted: return 0
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sync_NotificationSoundPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_NotificationSoundPolicy] = [
    .muted,
  ]
}

#endif  // swift(>=4.2)

/// Visibility of a conversation.
enum Sync_ConversationVisibility: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Appears normally in the list of conversations
  case normal // = 0

  /// Appears pinned in the list of conversations
  case pinned // = 2

  /// Appears in the archived list of conversations
  case archived // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .normal
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .normal
    case 1: self = .archived
    case 2: self = .pinned
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .normal: return 0
    case .archived: return 1
    case .pinned: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sync_ConversationVisibility: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_ConversationVisibility] = [
    .normal,
    .pinned,
    .archived,
  ]
}

#endif  // swift(>=4.2)

/// Category of a conversation.
enum Sync_ConversationCategory: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// No specific (default) category
  case `default` // = 0

  /// Protected conversation (_private chat_)
  case protected // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .default
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .default
    case 1: self = .protected
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .default: return 0
    case .protected: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Sync_ConversationCategory: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_ConversationCategory] = [
    .default,
    .protected,
  ]
}

#endif  // swift(>=4.2)

/// Mobile device management parameters shared across Threema Work devices.
///
/// More detailed parameter information is available here:
/// https://work.threema.ch/en/docs/mdm_configuration
struct Sync_MdmParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Username required for activation of the app
  /// References: `th_license_username`
  var licenseUsername: String {
    get {return _storage._licenseUsername ?? String()}
    set {_uniqueStorage()._licenseUsername = newValue}
  }
  /// Returns true if `licenseUsername` has been explicitly set.
  var hasLicenseUsername: Bool {return _storage._licenseUsername != nil}
  /// Clears the value of `licenseUsername`. Subsequent reads from it will return its default value.
  mutating func clearLicenseUsername() {_uniqueStorage()._licenseUsername = nil}

  /// Password required for activation of the app
  /// References: `th_license_password`
  var licensePassword: String {
    get {return _storage._licensePassword ?? String()}
    set {_uniqueStorage()._licensePassword = newValue}
  }
  /// Returns true if `licensePassword` has been explicitly set.
  var hasLicensePassword: Bool {return _storage._licensePassword != nil}
  /// Clears the value of `licensePassword`. Subsequent reads from it will return its default value.
  mutating func clearLicensePassword() {_uniqueStorage()._licensePassword = nil}

  /// Nickname to be used
  /// References: `th_nickname`
  var nickname: String {
    get {return _storage._nickname ?? String()}
    set {_uniqueStorage()._nickname = newValue}
  }
  /// Returns true if `nickname` has been explicitly set.
  var hasNickname: Bool {return _storage._nickname != nil}
  /// Clears the value of `nickname`. Subsequent reads from it will return its default value.
  mutating func clearNickname() {_uniqueStorage()._nickname = nil}

  /// First name of the user
  /// References: `th_firstname`
  var firstName: String {
    get {return _storage._firstName ?? String()}
    set {_uniqueStorage()._firstName = newValue}
  }
  /// Returns true if `firstName` has been explicitly set.
  var hasFirstName: Bool {return _storage._firstName != nil}
  /// Clears the value of `firstName`. Subsequent reads from it will return its default value.
  mutating func clearFirstName() {_uniqueStorage()._firstName = nil}

  /// Last name of the user
  /// References: `th_lastname`
  var lastName: String {
    get {return _storage._lastName ?? String()}
    set {_uniqueStorage()._lastName = newValue}
  }
  /// Returns true if `lastName` has been explicitly set.
  var hasLastName: Bool {return _storage._lastName != nil}
  /// Clears the value of `lastName`. Subsequent reads from it will return its default value.
  mutating func clearLastName() {_uniqueStorage()._lastName = nil}

  /// Customer specific identifier
  /// References: `th_csi`
  var customerSpecificID: String {
    get {return _storage._customerSpecificID ?? String()}
    set {_uniqueStorage()._customerSpecificID = newValue}
  }
  /// Returns true if `customerSpecificID` has been explicitly set.
  var hasCustomerSpecificID: Bool {return _storage._customerSpecificID != nil}
  /// Clears the value of `customerSpecificID`. Subsequent reads from it will return its default value.
  mutating func clearCustomerSpecificID() {_uniqueStorage()._customerSpecificID = nil}

  /// User category
  /// References: `th_category`
  var category: String {
    get {return _storage._category ?? String()}
    set {_uniqueStorage()._category = newValue}
  }
  /// Returns true if `category` has been explicitly set.
  var hasCategory: Bool {return _storage._category != nil}
  /// Clears the value of `category`. Subsequent reads from it will return its default value.
  mutating func clearCategory() {_uniqueStorage()._category = nil}

  /// Email address linked to the ID
  /// References: `th_linked_email`
  var linkedEmail: String {
    get {return _storage._linkedEmail ?? String()}
    set {_uniqueStorage()._linkedEmail = newValue}
  }
  /// Returns true if `linkedEmail` has been explicitly set.
  var hasLinkedEmail: Bool {return _storage._linkedEmail != nil}
  /// Clears the value of `linkedEmail`. Subsequent reads from it will return its default value.
  mutating func clearLinkedEmail() {_uniqueStorage()._linkedEmail = nil}

  /// Phone number linked to the ID
  /// References: `th_linked_phone`
  var linkedPhone: String {
    get {return _storage._linkedPhone ?? String()}
    set {_uniqueStorage()._linkedPhone = newValue}
  }
  /// Returns true if `linkedPhone` has been explicitly set.
  var hasLinkedPhone: Bool {return _storage._linkedPhone != nil}
  /// Clears the value of `linkedPhone`. Subsequent reads from it will return its default value.
  mutating func clearLinkedPhone() {_uniqueStorage()._linkedPhone = nil}

  /// Restore a Threema ID
  /// References: `th_id_backup`
  var identityRestore: String {
    get {return _storage._identityRestore ?? String()}
    set {_uniqueStorage()._identityRestore = newValue}
  }
  /// Returns true if `identityRestore` has been explicitly set.
  var hasIdentityRestore: Bool {return _storage._identityRestore != nil}
  /// Clears the value of `identityRestore`. Subsequent reads from it will return its default value.
  mutating func clearIdentityRestore() {_uniqueStorage()._identityRestore = nil}

  /// Password for restoring a Threema ID
  /// References: `th_id_backup_password`
  var identityRestorePassword: String {
    get {return _storage._identityRestorePassword ?? String()}
    set {_uniqueStorage()._identityRestorePassword = newValue}
  }
  /// Returns true if `identityRestorePassword` has been explicitly set.
  var hasIdentityRestorePassword: Bool {return _storage._identityRestorePassword != nil}
  /// Clears the value of `identityRestorePassword`. Subsequent reads from it will return its default value.
  mutating func clearIdentityRestorePassword() {_uniqueStorage()._identityRestorePassword = nil}

  var threemaSafePolicy: Sync_MdmParameters.ThreemaSafePolicy {
    get {return _storage._threemaSafePolicy ?? .safeOptional}
    set {_uniqueStorage()._threemaSafePolicy = newValue}
  }
  /// Returns true if `threemaSafePolicy` has been explicitly set.
  var hasThreemaSafePolicy: Bool {return _storage._threemaSafePolicy != nil}
  /// Clears the value of `threemaSafePolicy`. Subsequent reads from it will return its default value.
  mutating func clearThreemaSafePolicy() {_uniqueStorage()._threemaSafePolicy = nil}

  /// Threema Safe password (predefined)
  /// References: `th_safe_password`
  var threemaSafePassword: String {
    get {return _storage._threemaSafePassword ?? String()}
    set {_uniqueStorage()._threemaSafePassword = newValue}
  }
  /// Returns true if `threemaSafePassword` has been explicitly set.
  var hasThreemaSafePassword: Bool {return _storage._threemaSafePassword != nil}
  /// Clears the value of `threemaSafePassword`. Subsequent reads from it will return its default value.
  mutating func clearThreemaSafePassword() {_uniqueStorage()._threemaSafePassword = nil}

  /// Threema Safe password pattern
  /// References: `th_safe_password_pattern`
  var threemaSafePasswordPattern: String {
    get {return _storage._threemaSafePasswordPattern ?? String()}
    set {_uniqueStorage()._threemaSafePasswordPattern = newValue}
  }
  /// Returns true if `threemaSafePasswordPattern` has been explicitly set.
  var hasThreemaSafePasswordPattern: Bool {return _storage._threemaSafePasswordPattern != nil}
  /// Clears the value of `threemaSafePasswordPattern`. Subsequent reads from it will return its default value.
  mutating func clearThreemaSafePasswordPattern() {_uniqueStorage()._threemaSafePasswordPattern = nil}

  /// Threema Safe password pattern error (mismatch) message
  /// References: `th_safe_password_message`
  var threemaSafePasswordPatternErrorMessage: String {
    get {return _storage._threemaSafePasswordPatternErrorMessage ?? String()}
    set {_uniqueStorage()._threemaSafePasswordPatternErrorMessage = newValue}
  }
  /// Returns true if `threemaSafePasswordPatternErrorMessage` has been explicitly set.
  var hasThreemaSafePasswordPatternErrorMessage: Bool {return _storage._threemaSafePasswordPatternErrorMessage != nil}
  /// Clears the value of `threemaSafePasswordPatternErrorMessage`. Subsequent reads from it will return its default value.
  mutating func clearThreemaSafePasswordPatternErrorMessage() {_uniqueStorage()._threemaSafePasswordPatternErrorMessage = nil}

  /// Threema Safe server URL
  /// References: `th_safe_server_url`
  var threemaSafeServerURL: String {
    get {return _storage._threemaSafeServerURL ?? String()}
    set {_uniqueStorage()._threemaSafeServerURL = newValue}
  }
  /// Returns true if `threemaSafeServerURL` has been explicitly set.
  var hasThreemaSafeServerURL: Bool {return _storage._threemaSafeServerURL != nil}
  /// Clears the value of `threemaSafeServerURL`. Subsequent reads from it will return its default value.
  mutating func clearThreemaSafeServerURL() {_uniqueStorage()._threemaSafeServerURL = nil}

  /// Threema Safe server username for authentication
  /// References: `th_safe_server_username`
  var threemaSafeServerUsername: String {
    get {return _storage._threemaSafeServerUsername ?? String()}
    set {_uniqueStorage()._threemaSafeServerUsername = newValue}
  }
  /// Returns true if `threemaSafeServerUsername` has been explicitly set.
  var hasThreemaSafeServerUsername: Bool {return _storage._threemaSafeServerUsername != nil}
  /// Clears the value of `threemaSafeServerUsername`. Subsequent reads from it will return its default value.
  mutating func clearThreemaSafeServerUsername() {_uniqueStorage()._threemaSafeServerUsername = nil}

  /// Threema Safe server password for authentication
  /// References: `th_safe_server_password`
  var threemaSafeServerPassword: String {
    get {return _storage._threemaSafeServerPassword ?? String()}
    set {_uniqueStorage()._threemaSafeServerPassword = newValue}
  }
  /// Returns true if `threemaSafeServerPassword` has been explicitly set.
  var hasThreemaSafeServerPassword: Bool {return _storage._threemaSafeServerPassword != nil}
  /// Clears the value of `threemaSafeServerPassword`. Subsequent reads from it will return its default value.
  mutating func clearThreemaSafeServerPassword() {_uniqueStorage()._threemaSafeServerPassword = nil}

  var threemaSafeRestorePolicy: Sync_MdmParameters.ThreemaSafeRestorePolicy {
    get {return _storage._threemaSafeRestorePolicy ?? .safeRestoreOptional}
    set {_uniqueStorage()._threemaSafeRestorePolicy = newValue}
  }
  /// Returns true if `threemaSafeRestorePolicy` has been explicitly set.
  var hasThreemaSafeRestorePolicy: Bool {return _storage._threemaSafeRestorePolicy != nil}
  /// Clears the value of `threemaSafeRestorePolicy`. Subsequent reads from it will return its default value.
  mutating func clearThreemaSafeRestorePolicy() {_uniqueStorage()._threemaSafeRestorePolicy = nil}

  /// Threema ID to be restored from Threema Safe (required)
  /// References: `th_safe_restore_id`
  var threemaSafeRestoreIdentity: String {
    get {return _storage._threemaSafeRestoreIdentity ?? String()}
    set {_uniqueStorage()._threemaSafeRestoreIdentity = newValue}
  }
  /// Returns true if `threemaSafeRestoreIdentity` has been explicitly set.
  var hasThreemaSafeRestoreIdentity: Bool {return _storage._threemaSafeRestoreIdentity != nil}
  /// Clears the value of `threemaSafeRestoreIdentity`. Subsequent reads from it will return its default value.
  mutating func clearThreemaSafeRestoreIdentity() {_uniqueStorage()._threemaSafeRestoreIdentity = nil}

  var overridePolicy: Sync_MdmParameters.OverridePolicy {
    get {return _storage._overridePolicy ?? .loose}
    set {_uniqueStorage()._overridePolicy = newValue}
  }
  /// Returns true if `overridePolicy` has been explicitly set.
  var hasOverridePolicy: Bool {return _storage._overridePolicy != nil}
  /// Clears the value of `overridePolicy`. Subsequent reads from it will return its default value.
  mutating func clearOverridePolicy() {_uniqueStorage()._overridePolicy = nil}

  var contactSyncPolicy: Sync_MdmParameters.ContactSyncPolicy {
    get {return _storage._contactSyncPolicy ?? .notSynced}
    set {_uniqueStorage()._contactSyncPolicy = newValue}
  }
  /// Returns true if `contactSyncPolicy` has been explicitly set.
  var hasContactSyncPolicy: Bool {return _storage._contactSyncPolicy != nil}
  /// Clears the value of `contactSyncPolicy`. Subsequent reads from it will return its default value.
  mutating func clearContactSyncPolicy() {_uniqueStorage()._contactSyncPolicy = nil}

  var inactiveIdentityDisplayPolicy: Sync_MdmParameters.InactiveIdentityDisplayPolicy {
    get {return _storage._inactiveIdentityDisplayPolicy ?? .showInactive}
    set {_uniqueStorage()._inactiveIdentityDisplayPolicy = newValue}
  }
  /// Returns true if `inactiveIdentityDisplayPolicy` has been explicitly set.
  var hasInactiveIdentityDisplayPolicy: Bool {return _storage._inactiveIdentityDisplayPolicy != nil}
  /// Clears the value of `inactiveIdentityDisplayPolicy`. Subsequent reads from it will return its default value.
  mutating func clearInactiveIdentityDisplayPolicy() {_uniqueStorage()._inactiveIdentityDisplayPolicy = nil}

  var unknownContactPolicy: Sync_MdmParameters.UnknownContactPolicy {
    get {return _storage._unknownContactPolicy ?? .allowUnknown}
    set {_uniqueStorage()._unknownContactPolicy = newValue}
  }
  /// Returns true if `unknownContactPolicy` has been explicitly set.
  var hasUnknownContactPolicy: Bool {return _storage._unknownContactPolicy != nil}
  /// Clears the value of `unknownContactPolicy`. Subsequent reads from it will return its default value.
  mutating func clearUnknownContactPolicy() {_uniqueStorage()._unknownContactPolicy = nil}

  var autoSaveMediaPolicy: Sync_MdmParameters.AutoSaveMediaPolicy {
    get {return _storage._autoSaveMediaPolicy ?? .allowAutoSave}
    set {_uniqueStorage()._autoSaveMediaPolicy = newValue}
  }
  /// Returns true if `autoSaveMediaPolicy` has been explicitly set.
  var hasAutoSaveMediaPolicy: Bool {return _storage._autoSaveMediaPolicy != nil}
  /// Clears the value of `autoSaveMediaPolicy`. Subsequent reads from it will return its default value.
  mutating func clearAutoSaveMediaPolicy() {_uniqueStorage()._autoSaveMediaPolicy = nil}

  var screenshotPolicy: Sync_MdmParameters.ScreenshotPolicy {
    get {return _storage._screenshotPolicy ?? .allowScreenshot}
    set {_uniqueStorage()._screenshotPolicy = newValue}
  }
  /// Returns true if `screenshotPolicy` has been explicitly set.
  var hasScreenshotPolicy: Bool {return _storage._screenshotPolicy != nil}
  /// Clears the value of `screenshotPolicy`. Subsequent reads from it will return its default value.
  mutating func clearScreenshotPolicy() {_uniqueStorage()._screenshotPolicy = nil}

  var addContactPolicy: Sync_MdmParameters.AddContactPolicy {
    get {return _storage._addContactPolicy ?? .allowAddContact}
    set {_uniqueStorage()._addContactPolicy = newValue}
  }
  /// Returns true if `addContactPolicy` has been explicitly set.
  var hasAddContactPolicy: Bool {return _storage._addContactPolicy != nil}
  /// Clears the value of `addContactPolicy`. Subsequent reads from it will return its default value.
  mutating func clearAddContactPolicy() {_uniqueStorage()._addContactPolicy = nil}

  var chatExportPolicy: Sync_MdmParameters.ChatExportPolicy {
    get {return _storage._chatExportPolicy ?? .allowChatExport}
    set {_uniqueStorage()._chatExportPolicy = newValue}
  }
  /// Returns true if `chatExportPolicy` has been explicitly set.
  var hasChatExportPolicy: Bool {return _storage._chatExportPolicy != nil}
  /// Clears the value of `chatExportPolicy`. Subsequent reads from it will return its default value.
  mutating func clearChatExportPolicy() {_uniqueStorage()._chatExportPolicy = nil}

  var backupPolicy: Sync_MdmParameters.BackupPolicy {
    get {return _storage._backupPolicy ?? .allowBackup}
    set {_uniqueStorage()._backupPolicy = newValue}
  }
  /// Returns true if `backupPolicy` has been explicitly set.
  var hasBackupPolicy: Bool {return _storage._backupPolicy != nil}
  /// Clears the value of `backupPolicy`. Subsequent reads from it will return its default value.
  mutating func clearBackupPolicy() {_uniqueStorage()._backupPolicy = nil}

  var identityExportPolicy: Sync_MdmParameters.IdentityExportPolicy {
    get {return _storage._identityExportPolicy ?? .allowIdentityExport}
    set {_uniqueStorage()._identityExportPolicy = newValue}
  }
  /// Returns true if `identityExportPolicy` has been explicitly set.
  var hasIdentityExportPolicy: Bool {return _storage._identityExportPolicy != nil}
  /// Clears the value of `identityExportPolicy`. Subsequent reads from it will return its default value.
  mutating func clearIdentityExportPolicy() {_uniqueStorage()._identityExportPolicy = nil}

  var dataBackupPolicy: Sync_MdmParameters.DataBackupPolicy {
    get {return _storage._dataBackupPolicy ?? .allowDataBackup}
    set {_uniqueStorage()._dataBackupPolicy = newValue}
  }
  /// Returns true if `dataBackupPolicy` has been explicitly set.
  var hasDataBackupPolicy: Bool {return _storage._dataBackupPolicy != nil}
  /// Clears the value of `dataBackupPolicy`. Subsequent reads from it will return its default value.
  mutating func clearDataBackupPolicy() {_uniqueStorage()._dataBackupPolicy = nil}

  var systemBackupPolicy: Sync_MdmParameters.SystemBackupPolicy {
    get {return _storage._systemBackupPolicy ?? .allowSystemBackup}
    set {_uniqueStorage()._systemBackupPolicy = newValue}
  }
  /// Returns true if `systemBackupPolicy` has been explicitly set.
  var hasSystemBackupPolicy: Bool {return _storage._systemBackupPolicy != nil}
  /// Clears the value of `systemBackupPolicy`. Subsequent reads from it will return its default value.
  mutating func clearSystemBackupPolicy() {_uniqueStorage()._systemBackupPolicy = nil}

  var messagePreviewPolicy: Sync_MdmParameters.MessagePreviewPolicy {
    get {return _storage._messagePreviewPolicy ?? .allowPreview}
    set {_uniqueStorage()._messagePreviewPolicy = newValue}
  }
  /// Returns true if `messagePreviewPolicy` has been explicitly set.
  var hasMessagePreviewPolicy: Bool {return _storage._messagePreviewPolicy != nil}
  /// Clears the value of `messagePreviewPolicy`. Subsequent reads from it will return its default value.
  mutating func clearMessagePreviewPolicy() {_uniqueStorage()._messagePreviewPolicy = nil}

  var profilePictureSharePolicy: Sync_MdmParameters.ProfilePictureSharePolicy {
    get {return _storage._profilePictureSharePolicy ?? .allowShare}
    set {_uniqueStorage()._profilePictureSharePolicy = newValue}
  }
  /// Returns true if `profilePictureSharePolicy` has been explicitly set.
  var hasProfilePictureSharePolicy: Bool {return _storage._profilePictureSharePolicy != nil}
  /// Clears the value of `profilePictureSharePolicy`. Subsequent reads from it will return its default value.
  mutating func clearProfilePictureSharePolicy() {_uniqueStorage()._profilePictureSharePolicy = nil}

  var callPolicy: Sync_MdmParameters.CallPolicy {
    get {return _storage._callPolicy ?? .allowCall}
    set {_uniqueStorage()._callPolicy = newValue}
  }
  /// Returns true if `callPolicy` has been explicitly set.
  var hasCallPolicy: Bool {return _storage._callPolicy != nil}
  /// Clears the value of `callPolicy`. Subsequent reads from it will return its default value.
  mutating func clearCallPolicy() {_uniqueStorage()._callPolicy = nil}

  var setupWizardPolicy: Sync_MdmParameters.SetupWizardPolicy {
    get {return _storage._setupWizardPolicy ?? .showWizard}
    set {_uniqueStorage()._setupWizardPolicy = newValue}
  }
  /// Returns true if `setupWizardPolicy` has been explicitly set.
  var hasSetupWizardPolicy: Bool {return _storage._setupWizardPolicy != nil}
  /// Clears the value of `setupWizardPolicy`. Subsequent reads from it will return its default value.
  mutating func clearSetupWizardPolicy() {_uniqueStorage()._setupWizardPolicy = nil}

  var createGroupPolicy: Sync_MdmParameters.CreateGroupPolicy {
    get {return _storage._createGroupPolicy ?? .allowCreateGroup}
    set {_uniqueStorage()._createGroupPolicy = newValue}
  }
  /// Returns true if `createGroupPolicy` has been explicitly set.
  var hasCreateGroupPolicy: Bool {return _storage._createGroupPolicy != nil}
  /// Clears the value of `createGroupPolicy`. Subsequent reads from it will return its default value.
  mutating func clearCreateGroupPolicy() {_uniqueStorage()._createGroupPolicy = nil}

  var shareMediaPolicy: Sync_MdmParameters.ShareMediaPolicy {
    get {return _storage._shareMediaPolicy ?? .allowShareMedia}
    set {_uniqueStorage()._shareMediaPolicy = newValue}
  }
  /// Returns true if `shareMediaPolicy` has been explicitly set.
  var hasShareMediaPolicy: Bool {return _storage._shareMediaPolicy != nil}
  /// Clears the value of `shareMediaPolicy`. Subsequent reads from it will return its default value.
  mutating func clearShareMediaPolicy() {_uniqueStorage()._shareMediaPolicy = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Threema Safe configuration (required)
  /// References: `th_safe_enable`
  enum ThreemaSafePolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Configurable by the user
    case safeOptional // = 0

    /// Forcibly enabled
    case safeMandatory // = 1

    /// Forcibly disabled
    case safeDisabled // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .safeOptional
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .safeOptional
      case 1: self = .safeMandatory
      case 2: self = .safeDisabled
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .safeOptional: return 0
      case .safeMandatory: return 1
      case .safeDisabled: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Restore policy for restoring from a Threema Safe backup (required)
  /// References: `th_safe_restore_enable`
  enum ThreemaSafeRestorePolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Choosable by the user
    case safeRestoreOptional // = 0

    /// Automatic restore
    case safeRestoreMandatory // = 1

    /// Forcibly disabled
    case safeRestoreDisabled // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .safeRestoreOptional
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .safeRestoreOptional
      case 1: self = .safeRestoreMandatory
      case 2: self = .safeRestoreDisabled
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .safeRestoreOptional: return 0
      case .safeRestoreMandatory: return 1
      case .safeRestoreDisabled: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Override policy in regards to MDM parameters (required)
  /// References: `th_readonly_profile`
  enum OverridePolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Allows the user to override some of the MDM parameter presets
    case loose // = 0

    /// The user may not override any MDM parameter presets
    case strict // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .loose
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .loose
      case 1: self = .strict
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .loose: return 0
      case .strict: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Contact synchronisation policy (required)
  /// References: `th_contact_sync`
  enum ContactSyncPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Not synced
    case notSynced // = 0

    /// Synced
    case sync // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .notSynced
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .notSynced
      case 1: self = .sync
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .notSynced: return 0
      case .sync: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Inactive Threema ID display policy (required)
  /// References: `th_hide_inactive_ids`
  enum InactiveIdentityDisplayPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Show inactive IDs
    case showInactive // = 0

    /// Hide inactive IDs
    case hideInactive // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .showInactive
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .showInactive
      case 1: self = .hideInactive
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .showInactive: return 0
      case .hideInactive: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Unknown contacts policy (required)
  /// References: `th_block_unknown`
  enum UnknownContactPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Allowed to contact the user
    case allowUnknown // = 0

    /// Will be blocked by the user
    case blockUnknown // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowUnknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowUnknown
      case 1: self = .blockUnknown
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowUnknown: return 0
      case .blockUnknown: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Auto-save media policy (required)
  /// References: `th_disable_save_to_gallery`
  enum AutoSaveMediaPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Allow auto-saving, configurable by the user
    case allowAutoSave // = 0

    /// Deny auto-saving
    case denyAutoSave // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowAutoSave
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowAutoSave
      case 1: self = .denyAutoSave
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowAutoSave: return 0
      case .denyAutoSave: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Screenshot policy (required)
  /// References: `th_disable_screenshots`
  enum ScreenshotPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Allow taking screenshots
    case allowScreenshot // = 0

    /// Deny taking screenshots, if possible
    case denyScreenshot // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowScreenshot
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowScreenshot
      case 1: self = .denyScreenshot
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowScreenshot: return 0
      case .denyScreenshot: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Add contact policy (required)
  /// References: `th_disable_add_contact`
  enum AddContactPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Allow manually adding contacts
    case allowAddContact // = 0

    /// Deny manually adding contacts
    case denyAddContact // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowAddContact
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowAddContact
      case 1: self = .denyAddContact
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowAddContact: return 0
      case .denyAddContact: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Chat export policy (required)
  /// References: `th_disable_export`
  enum ChatExportPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Allow exporting chats
    case allowChatExport // = 0

    /// Deny exporting of chats
    case denyChatExport // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowChatExport
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowChatExport
      case 1: self = .denyChatExport
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowChatExport: return 0
      case .denyChatExport: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Backup policy (required)
  /// References: `th_disable_backups`
  enum BackupPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Generally allow backups to be made
    case allowBackup // = 0

    /// Deny creating backups
    case denyBackup // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowBackup
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowBackup
      case 1: self = .denyBackup
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowBackup: return 0
      case .denyBackup: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Threema ID export policy (required)
  /// References: `th_disable_id_export`
  enum IdentityExportPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Allow exporting of the Threema ID
    case allowIdentityExport // = 0

    /// Deny exporting of the Threema ID
    case denyIdentityExport // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowIdentityExport
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowIdentityExport
      case 1: self = .denyIdentityExport
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowIdentityExport: return 0
      case .denyIdentityExport: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Data backup policy (required)
  /// References: `th_disable_data_backups`
  enum DataBackupPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Allow creating data backups
    case allowDataBackup // = 0

    /// Deny creating data backups
    case denyDataBackup // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowDataBackup
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowDataBackup
      case 1: self = .denyDataBackup
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowDataBackup: return 0
      case .denyDataBackup: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// System backup policy (required)
  /// References: `th_disable_system_backups`
  enum SystemBackupPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// The system may include app data
    case allowSystemBackup // = 0

    /// The system is denied from including app data
    case denySystemBackup // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowSystemBackup
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowSystemBackup
      case 1: self = .denySystemBackup
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowSystemBackup: return 0
      case .denySystemBackup: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Message preview (required)
  /// References: `th_disable_message_preview`
  enum MessagePreviewPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Allow showing a message preview
    case allowPreview // = 0

    /// Deny showing a message preview
    case denyPreview // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowPreview
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowPreview
      case 1: self = .denyPreview
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowPreview: return 0
      case .denyPreview: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Profile picture sharing policy (required)
  /// References: `th_disable_send_profile_picture`
  enum ProfilePictureSharePolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Allow the profile picture to be shared with contacts
    case allowShare // = 0

    /// Denied from sharing the profile picture with contacts
    case denyShare // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowShare
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowShare
      case 1: self = .denyShare
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowShare: return 0
      case .denyShare: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Threema Call policy (required)
  /// References: `th_disable_calls`
  enum CallPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Allow creating/receiving Threema Calls
    case allowCall // = 0

    /// Denied from creating/receiving any Threema Calls
    case denyCall // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowCall
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowCall
      case 1: self = .denyCall
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowCall: return 0
      case .denyCall: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Setup wizard policy (required)
  /// References: `th_skip_wizard`
  enum SetupWizardPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Show the setup wizard
    case showWizard // = 0

    /// Skip the setup wizard (restores an ID or a backup and sets up the
    /// profile automatically).
    case skipWizard // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .showWizard
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .showWizard
      case 1: self = .skipWizard
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .showWizard: return 0
      case .skipWizard: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Group creation policy (required)
  /// References: `th_disable_create_group`
  enum CreateGroupPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Allow manually creating groups
    case allowCreateGroup // = 0

    /// Deny manually creating groups
    case denyCreateGroup // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowCreateGroup
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowCreateGroup
      case 1: self = .denyCreateGroup
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowCreateGroup: return 0
      case .denyCreateGroup: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Share media policy (required)
  /// References: `th_disable_share_media`
  enum ShareMediaPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Allow unrestricted sharing of media
    case allowShareMedia // = 0

    /// Deny sharing of media outside of Threema, if possible
    case denyOutsideApp // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowShareMedia
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowShareMedia
      case 1: self = .denyOutsideApp
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowShareMedia: return 0
      case .denyOutsideApp: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Sync_MdmParameters.ThreemaSafePolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_MdmParameters.ThreemaSafePolicy] = [
    .safeOptional,
    .safeMandatory,
    .safeDisabled,
  ]
}

extension Sync_MdmParameters.ThreemaSafeRestorePolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_MdmParameters.ThreemaSafeRestorePolicy] = [
    .safeRestoreOptional,
    .safeRestoreMandatory,
    .safeRestoreDisabled,
  ]
}

extension Sync_MdmParameters.OverridePolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_MdmParameters.OverridePolicy] = [
    .loose,
    .strict,
  ]
}

extension Sync_MdmParameters.ContactSyncPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_MdmParameters.ContactSyncPolicy] = [
    .notSynced,
    .sync,
  ]
}

extension Sync_MdmParameters.InactiveIdentityDisplayPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_MdmParameters.InactiveIdentityDisplayPolicy] = [
    .showInactive,
    .hideInactive,
  ]
}

extension Sync_MdmParameters.UnknownContactPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_MdmParameters.UnknownContactPolicy] = [
    .allowUnknown,
    .blockUnknown,
  ]
}

extension Sync_MdmParameters.AutoSaveMediaPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_MdmParameters.AutoSaveMediaPolicy] = [
    .allowAutoSave,
    .denyAutoSave,
  ]
}

extension Sync_MdmParameters.ScreenshotPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_MdmParameters.ScreenshotPolicy] = [
    .allowScreenshot,
    .denyScreenshot,
  ]
}

extension Sync_MdmParameters.AddContactPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_MdmParameters.AddContactPolicy] = [
    .allowAddContact,
    .denyAddContact,
  ]
}

extension Sync_MdmParameters.ChatExportPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_MdmParameters.ChatExportPolicy] = [
    .allowChatExport,
    .denyChatExport,
  ]
}

extension Sync_MdmParameters.BackupPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_MdmParameters.BackupPolicy] = [
    .allowBackup,
    .denyBackup,
  ]
}

extension Sync_MdmParameters.IdentityExportPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_MdmParameters.IdentityExportPolicy] = [
    .allowIdentityExport,
    .denyIdentityExport,
  ]
}

extension Sync_MdmParameters.DataBackupPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_MdmParameters.DataBackupPolicy] = [
    .allowDataBackup,
    .denyDataBackup,
  ]
}

extension Sync_MdmParameters.SystemBackupPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_MdmParameters.SystemBackupPolicy] = [
    .allowSystemBackup,
    .denySystemBackup,
  ]
}

extension Sync_MdmParameters.MessagePreviewPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_MdmParameters.MessagePreviewPolicy] = [
    .allowPreview,
    .denyPreview,
  ]
}

extension Sync_MdmParameters.ProfilePictureSharePolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_MdmParameters.ProfilePictureSharePolicy] = [
    .allowShare,
    .denyShare,
  ]
}

extension Sync_MdmParameters.CallPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_MdmParameters.CallPolicy] = [
    .allowCall,
    .denyCall,
  ]
}

extension Sync_MdmParameters.SetupWizardPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_MdmParameters.SetupWizardPolicy] = [
    .showWizard,
    .skipWizard,
  ]
}

extension Sync_MdmParameters.CreateGroupPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_MdmParameters.CreateGroupPolicy] = [
    .allowCreateGroup,
    .denyCreateGroup,
  ]
}

extension Sync_MdmParameters.ShareMediaPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_MdmParameters.ShareMediaPolicy] = [
    .allowShareMedia,
    .denyOutsideApp,
  ]
}

#endif  // swift(>=4.2)

/// The user's profile.
struct Sync_UserProfile {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Nickname
  ///
  /// Required towards a new device. Optional otherwise.
  ///
  /// When the user cleared its nickname, send an empty string. Do not send the
  /// user's Threema ID (i.e. process data).
  ///
  /// When an empty string was received, store the empty string as-is and fall
  /// back to the users Threema ID when sending an end-to-end encrypted message.
  var nickname: String {
    get {return _nickname ?? String()}
    set {_nickname = newValue}
  }
  /// Returns true if `nickname` has been explicitly set.
  var hasNickname: Bool {return self._nickname != nil}
  /// Clears the value of `nickname`. Subsequent reads from it will return its default value.
  mutating func clearNickname() {self._nickname = nil}

  /// Profile picture
  ///
  /// Always optional.
  var profilePicture: Common_DeltaImage {
    get {return _profilePicture ?? Common_DeltaImage()}
    set {_profilePicture = newValue}
  }
  /// Returns true if `profilePicture` has been explicitly set.
  var hasProfilePicture: Bool {return self._profilePicture != nil}
  /// Clears the value of `profilePicture`. Subsequent reads from it will return its default value.
  mutating func clearProfilePicture() {self._profilePicture = nil}

  var profilePictureShareWith: Sync_UserProfile.ProfilePictureShareWith {
    get {return _profilePictureShareWith ?? Sync_UserProfile.ProfilePictureShareWith()}
    set {_profilePictureShareWith = newValue}
  }
  /// Returns true if `profilePictureShareWith` has been explicitly set.
  var hasProfilePictureShareWith: Bool {return self._profilePictureShareWith != nil}
  /// Clears the value of `profilePictureShareWith`. Subsequent reads from it will return its default value.
  mutating func clearProfilePictureShareWith() {self._profilePictureShareWith = nil}

  var identityLinks: Sync_UserProfile.IdentityLinks {
    get {return _identityLinks ?? Sync_UserProfile.IdentityLinks()}
    set {_identityLinks = newValue}
  }
  /// Returns true if `identityLinks` has been explicitly set.
  var hasIdentityLinks: Bool {return self._identityLinks != nil}
  /// Clears the value of `identityLinks`. Subsequent reads from it will return its default value.
  mutating func clearIdentityLinks() {self._identityLinks = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Profile picture share policy
  ///
  /// Required towards a new device. Optional otherwise.
  struct ProfilePictureShareWith {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var policy: Sync_UserProfile.ProfilePictureShareWith.OneOf_Policy? = nil

    /// Don't share
    var nobody: Common_Unit {
      get {
        if case .nobody(let v)? = policy {return v}
        return Common_Unit()
      }
      set {policy = .nobody(newValue)}
    }

    /// Share with everyone
    var everyone: Common_Unit {
      get {
        if case .everyone(let v)? = policy {return v}
        return Common_Unit()
      }
      set {policy = .everyone(newValue)}
    }

    /// Share only with explicitly listed contacts
    ///
    /// When the user selected _allow list_ but did not select any contacts,
    /// send an empty list. Do not fall back to `nobody`.
    var allowList: Common_Identities {
      get {
        if case .allowList(let v)? = policy {return v}
        return Common_Identities()
      }
      set {policy = .allowList(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Policy: Equatable {
      /// Don't share
      case nobody(Common_Unit)
      /// Share with everyone
      case everyone(Common_Unit)
      /// Share only with explicitly listed contacts
      ///
      /// When the user selected _allow list_ but did not select any contacts,
      /// send an empty list. Do not fall back to `nobody`.
      case allowList(Common_Identities)

    #if !swift(>=4.1)
      static func ==(lhs: Sync_UserProfile.ProfilePictureShareWith.OneOf_Policy, rhs: Sync_UserProfile.ProfilePictureShareWith.OneOf_Policy) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.nobody, .nobody): return {
          guard case .nobody(let l) = lhs, case .nobody(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.everyone, .everyone): return {
          guard case .everyone(let l) = lhs, case .everyone(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.allowList, .allowList): return {
          guard case .allowList(let l) = lhs, case .allowList(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    init() {}
  }

  /// External entities linked with the identity
  ///
  /// Required towards a new device. Optional otherwise.
  ///
  /// When the user has cleared all of its identity links, this message is
  /// present but `links` contains zero items.
  struct IdentityLinks {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// List of identity links
    var links: [Sync_UserProfile.IdentityLinks.IdentityLink] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    /// Threema ID link.
    struct IdentityLink {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// Identity link type
      var type: Sync_UserProfile.IdentityLinks.IdentityLink.OneOf_Type? = nil

      /// Linked with a verified telephone number (E.164 format without leading
      /// `+`)
      var phoneNumber: String {
        get {
          if case .phoneNumber(let v)? = type {return v}
          return String()
        }
        set {type = .phoneNumber(newValue)}
      }

      /// Linked with a verified email address
      var email: String {
        get {
          if case .email(let v)? = type {return v}
          return String()
        }
        set {type = .email(newValue)}
      }

      /// Identity link description
      var description_p: String = String()

      var unknownFields = SwiftProtobuf.UnknownStorage()

      /// Identity link type
      enum OneOf_Type: Equatable {
        /// Linked with a verified telephone number (E.164 format without leading
        /// `+`)
        case phoneNumber(String)
        /// Linked with a verified email address
        case email(String)

      #if !swift(>=4.1)
        static func ==(lhs: Sync_UserProfile.IdentityLinks.IdentityLink.OneOf_Type, rhs: Sync_UserProfile.IdentityLinks.IdentityLink.OneOf_Type) -> Bool {
          // The use of inline closures is to circumvent an issue where the compiler
          // allocates stack space for every case branch when no optimizations are
          // enabled. https://github.com/apple/swift-protobuf/issues/1034
          switch (lhs, rhs) {
          case (.phoneNumber, .phoneNumber): return {
            guard case .phoneNumber(let l) = lhs, case .phoneNumber(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          case (.email, .email): return {
            guard case .email(let l) = lhs, case .email(let r) = rhs else { preconditionFailure() }
            return l == r
          }()
          default: return false
          }
        }
      #endif
      }

      init() {}
    }

    init() {}
  }

  init() {}

  fileprivate var _nickname: String? = nil
  fileprivate var _profilePicture: Common_DeltaImage? = nil
  fileprivate var _profilePictureShareWith: Sync_UserProfile.ProfilePictureShareWith? = nil
  fileprivate var _identityLinks: Sync_UserProfile.IdentityLinks? = nil
}

/// Threema contact.
struct Sync_Contact {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Threema ID of the contact
  ///
  /// Always required.
  var identity: String {
    get {return _storage._identity}
    set {_uniqueStorage()._identity = newValue}
  }

  /// Public key of the contact
  ///
  /// Required towards a new device and for a new contact. Should not be set
  /// for existing contacts and must be ignored (a public key for an identity
  /// cannot be changed).
  var publicKey: Data {
    get {return _storage._publicKey ?? Data()}
    set {_uniqueStorage()._publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return _storage._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {_uniqueStorage()._publicKey = nil}

  /// Unix-ish timestamp in milliseconds when the contact has been created
  /// (added) locally.
  ///
  /// Required towards a new device and for a new contact. Optional for an
  /// existing contact.
  var createdAt: UInt64 {
    get {return _storage._createdAt ?? 0}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  /// First name of the contact
  ///
  /// Always optional.
  ///
  /// An empty string is valid. When both `first_name` and `last_name` are
  /// empty string, the `nickname` should be used as display name.
  var firstName: String {
    get {return _storage._firstName ?? String()}
    set {_uniqueStorage()._firstName = newValue}
  }
  /// Returns true if `firstName` has been explicitly set.
  var hasFirstName: Bool {return _storage._firstName != nil}
  /// Clears the value of `firstName`. Subsequent reads from it will return its default value.
  mutating func clearFirstName() {_uniqueStorage()._firstName = nil}

  /// Last name of the contact
  ///
  /// Always optional.
  ///
  /// An empty string is valid. When both `first_name` and `last_name` are
  /// empty string, the `nickname` should be used as display name.
  var lastName: String {
    get {return _storage._lastName ?? String()}
    set {_uniqueStorage()._lastName = newValue}
  }
  /// Returns true if `lastName` has been explicitly set.
  var hasLastName: Bool {return _storage._lastName != nil}
  /// Clears the value of `lastName`. Subsequent reads from it will return its default value.
  mutating func clearLastName() {_uniqueStorage()._lastName = nil}

  /// Nickname of the contact (without `~` prefix)
  ///
  /// Always optional.
  ///
  /// An empty string is valid. If `first_name`, `last_name` and `nickname` are
  /// empty string, the Threema ID should be used as display name.
  var nickname: String {
    get {return _storage._nickname ?? String()}
    set {_uniqueStorage()._nickname = newValue}
  }
  /// Returns true if `nickname` has been explicitly set.
  var hasNickname: Bool {return _storage._nickname != nil}
  /// Clears the value of `nickname`. Subsequent reads from it will return its default value.
  mutating func clearNickname() {_uniqueStorage()._nickname = nil}

  var verificationLevel: Sync_Contact.VerificationLevel {
    get {return _storage._verificationLevel ?? .unverified}
    set {_uniqueStorage()._verificationLevel = newValue}
  }
  /// Returns true if `verificationLevel` has been explicitly set.
  var hasVerificationLevel: Bool {return _storage._verificationLevel != nil}
  /// Clears the value of `verificationLevel`. Subsequent reads from it will return its default value.
  mutating func clearVerificationLevel() {_uniqueStorage()._verificationLevel = nil}

  var workVerificationLevel: Sync_Contact.WorkVerificationLevel {
    get {return _storage._workVerificationLevel ?? .none}
    set {_uniqueStorage()._workVerificationLevel = newValue}
  }
  /// Returns true if `workVerificationLevel` has been explicitly set.
  var hasWorkVerificationLevel: Bool {return _storage._workVerificationLevel != nil}
  /// Clears the value of `workVerificationLevel`. Subsequent reads from it will return its default value.
  mutating func clearWorkVerificationLevel() {_uniqueStorage()._workVerificationLevel = nil}

  var identityType: Sync_Contact.IdentityType {
    get {return _storage._identityType ?? .regular}
    set {_uniqueStorage()._identityType = newValue}
  }
  /// Returns true if `identityType` has been explicitly set.
  var hasIdentityType: Bool {return _storage._identityType != nil}
  /// Clears the value of `identityType`. Subsequent reads from it will return its default value.
  mutating func clearIdentityType() {_uniqueStorage()._identityType = nil}

  var acquaintanceLevel: Sync_Contact.AcquaintanceLevel {
    get {return _storage._acquaintanceLevel ?? .direct}
    set {_uniqueStorage()._acquaintanceLevel = newValue}
  }
  /// Returns true if `acquaintanceLevel` has been explicitly set.
  var hasAcquaintanceLevel: Bool {return _storage._acquaintanceLevel != nil}
  /// Clears the value of `acquaintanceLevel`. Subsequent reads from it will return its default value.
  mutating func clearAcquaintanceLevel() {_uniqueStorage()._acquaintanceLevel = nil}

  var activityState: Sync_Contact.ActivityState {
    get {return _storage._activityState ?? .active}
    set {_uniqueStorage()._activityState = newValue}
  }
  /// Returns true if `activityState` has been explicitly set.
  var hasActivityState: Bool {return _storage._activityState != nil}
  /// Clears the value of `activityState`. Subsequent reads from it will return its default value.
  mutating func clearActivityState() {_uniqueStorage()._activityState = nil}

  /// Features available for the contact (32 bit mask).
  ///
  /// - `0x00_00_00_01`: Can handle audio messages.
  /// - `0x00_00_00_02`: Can handle groups.
  /// - `0x00_00_00_04`: Can handle polls.
  /// - `0x00_00_00_08`: Can handle file messages.
  /// - `0x00_00_00_10`: Can handle audio calls.
  /// - `0x00_00_00_20`: Can handle video calls.
  ///
  /// Required towards a new device and for a new contact. Optional for an
  /// existing contact.
  var featureMask: UInt32 {
    get {return _storage._featureMask ?? 0}
    set {_uniqueStorage()._featureMask = newValue}
  }
  /// Returns true if `featureMask` has been explicitly set.
  var hasFeatureMask: Bool {return _storage._featureMask != nil}
  /// Clears the value of `featureMask`. Subsequent reads from it will return its default value.
  mutating func clearFeatureMask() {_uniqueStorage()._featureMask = nil}

  var syncState: Sync_Contact.SyncState {
    get {return _storage._syncState ?? .initial}
    set {_uniqueStorage()._syncState = newValue}
  }
  /// Returns true if `syncState` has been explicitly set.
  var hasSyncState: Bool {return _storage._syncState != nil}
  /// Clears the value of `syncState`. Subsequent reads from it will return its default value.
  mutating func clearSyncState() {_uniqueStorage()._syncState = nil}

  var readReceiptPolicyOverride: Sync_Contact.ReadReceiptPolicyOverride {
    get {return _storage._readReceiptPolicyOverride ?? Sync_Contact.ReadReceiptPolicyOverride()}
    set {_uniqueStorage()._readReceiptPolicyOverride = newValue}
  }
  /// Returns true if `readReceiptPolicyOverride` has been explicitly set.
  var hasReadReceiptPolicyOverride: Bool {return _storage._readReceiptPolicyOverride != nil}
  /// Clears the value of `readReceiptPolicyOverride`. Subsequent reads from it will return its default value.
  mutating func clearReadReceiptPolicyOverride() {_uniqueStorage()._readReceiptPolicyOverride = nil}

  var typingIndicatorPolicyOverride: Sync_Contact.TypingIndicatorPolicyOverride {
    get {return _storage._typingIndicatorPolicyOverride ?? Sync_Contact.TypingIndicatorPolicyOverride()}
    set {_uniqueStorage()._typingIndicatorPolicyOverride = newValue}
  }
  /// Returns true if `typingIndicatorPolicyOverride` has been explicitly set.
  var hasTypingIndicatorPolicyOverride: Bool {return _storage._typingIndicatorPolicyOverride != nil}
  /// Clears the value of `typingIndicatorPolicyOverride`. Subsequent reads from it will return its default value.
  mutating func clearTypingIndicatorPolicyOverride() {_uniqueStorage()._typingIndicatorPolicyOverride = nil}

  var notificationTriggerPolicyOverride: Sync_Contact.NotificationTriggerPolicyOverride {
    get {return _storage._notificationTriggerPolicyOverride ?? Sync_Contact.NotificationTriggerPolicyOverride()}
    set {_uniqueStorage()._notificationTriggerPolicyOverride = newValue}
  }
  /// Returns true if `notificationTriggerPolicyOverride` has been explicitly set.
  var hasNotificationTriggerPolicyOverride: Bool {return _storage._notificationTriggerPolicyOverride != nil}
  /// Clears the value of `notificationTriggerPolicyOverride`. Subsequent reads from it will return its default value.
  mutating func clearNotificationTriggerPolicyOverride() {_uniqueStorage()._notificationTriggerPolicyOverride = nil}

  var notificationSoundPolicyOverride: Sync_Contact.NotificationSoundPolicyOverride {
    get {return _storage._notificationSoundPolicyOverride ?? Sync_Contact.NotificationSoundPolicyOverride()}
    set {_uniqueStorage()._notificationSoundPolicyOverride = newValue}
  }
  /// Returns true if `notificationSoundPolicyOverride` has been explicitly set.
  var hasNotificationSoundPolicyOverride: Bool {return _storage._notificationSoundPolicyOverride != nil}
  /// Clears the value of `notificationSoundPolicyOverride`. Subsequent reads from it will return its default value.
  mutating func clearNotificationSoundPolicyOverride() {_uniqueStorage()._notificationSoundPolicyOverride = nil}

  /// Contact-defined profile picture as received from the contact in a
  /// `set-profile-picture` message.
  ///
  /// Always optional.
  var contactDefinedProfilePicture: Common_DeltaImage {
    get {return _storage._contactDefinedProfilePicture ?? Common_DeltaImage()}
    set {_uniqueStorage()._contactDefinedProfilePicture = newValue}
  }
  /// Returns true if `contactDefinedProfilePicture` has been explicitly set.
  var hasContactDefinedProfilePicture: Bool {return _storage._contactDefinedProfilePicture != nil}
  /// Clears the value of `contactDefinedProfilePicture`. Subsequent reads from it will return its default value.
  mutating func clearContactDefinedProfilePicture() {_uniqueStorage()._contactDefinedProfilePicture = nil}

  /// User-defined profile picture set by the user or imported from the address
  /// book.
  ///
  /// Always optional.
  var userDefinedProfilePicture: Common_DeltaImage {
    get {return _storage._userDefinedProfilePicture ?? Common_DeltaImage()}
    set {_uniqueStorage()._userDefinedProfilePicture = newValue}
  }
  /// Returns true if `userDefinedProfilePicture` has been explicitly set.
  var hasUserDefinedProfilePicture: Bool {return _storage._userDefinedProfilePicture != nil}
  /// Clears the value of `userDefinedProfilePicture`. Subsequent reads from it will return its default value.
  mutating func clearUserDefinedProfilePicture() {_uniqueStorage()._userDefinedProfilePicture = nil}

  /// Conversation category of the contact
  ///
  /// Required towards a new device and for a new contact. Optional for an
  /// existing contact.
  var conversationCategory: Sync_ConversationCategory {
    get {return _storage._conversationCategory ?? .default}
    set {_uniqueStorage()._conversationCategory = newValue}
  }
  /// Returns true if `conversationCategory` has been explicitly set.
  var hasConversationCategory: Bool {return _storage._conversationCategory != nil}
  /// Clears the value of `conversationCategory`. Subsequent reads from it will return its default value.
  mutating func clearConversationCategory() {_uniqueStorage()._conversationCategory = nil}

  /// Conversation visbility of the contact
  ///
  /// Required towards a new device and for a new contact. Optional for an
  /// existing contact.
  var conversationVisibility: Sync_ConversationVisibility {
    get {return _storage._conversationVisibility ?? .normal}
    set {_uniqueStorage()._conversationVisibility = newValue}
  }
  /// Returns true if `conversationVisibility` has been explicitly set.
  var hasConversationVisibility: Bool {return _storage._conversationVisibility != nil}
  /// Clears the value of `conversationVisibility`. Subsequent reads from it will return its default value.
  mutating func clearConversationVisibility() {_uniqueStorage()._conversationVisibility = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Verification level of the contact
  ///
  /// Required towards a new device and for a new contact. Optional for an
  /// existing contact.
  ///
  /// Note: When applying logic depending on the verification level, a
  ///       `WorkVerificationLevel` of `WORK_SUBSCRIPTION_VERIFIED` virtually
  ///       raises the verification level to `SERVER_VERIFIED`. However, the
  ///       contact verification level takes precedence if it is
  ///       `FULLY_VERIFIED`.
  enum VerificationLevel: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Unverified, public key has been obtained from the server
    case unverified // = 0

    /// Verified with one of the account links via the server, or the contact
    /// has been obtained via the Work API.
    case serverVerified // = 1

    /// Verified, public key has been obtained via a secure channel
    case fullyVerified // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .unverified
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unverified
      case 1: self = .serverVerified
      case 2: self = .fullyVerified
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unverified: return 0
      case .serverVerified: return 1
      case .fullyVerified: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Threema Work verification level of the contact.
  ///
  /// Required towards a new device and for a new contact. Optional for an
  /// existing contact.
  ///
  /// Note: When not using a Threema Work client, the Threema Work verification
  ///       level must always be `NONE`.
  enum WorkVerificationLevel: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// The user does not use Threema Work or the contact is not in the same
    /// Threema Work subscription.
    case none // = 0

    /// The contact is in the same Threema Work subscription.
    case workSubscriptionVerified // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .none
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .none
      case 1: self = .workSubscriptionVerified
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .none: return 0
      case .workSubscriptionVerified: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Identity type of the contact
  ///
  /// Required towards a new device and for a new contact. Optional for an
  /// existing contact.
  enum IdentityType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Regular contact (uses the regular Threema app)
    case regular // = 0

    /// Work contact (uses the Threema work app)
    case work // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .regular
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .regular
      case 1: self = .work
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .regular: return 0
      case .work: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Acquaintance level of the contact
  ///
  /// Required towards a new device and for a new contact. Optional for an
  /// existing contact.
  enum AcquaintanceLevel: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// The contact was explicitly added by the user or a 1:1 conversation with
    /// the contact has been initiated.
    case direct // = 0

    /// The contact is part of a group the user is also part of. The contact was
    /// not explicitly added and no 1:1 conversation has been initiated.
    case group // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .direct
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .direct
      case 1: self = .group
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .direct: return 0
      case .group: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Activity state of the contact
  ///
  /// Required towards a new device and for a new contact. Optional for an
  /// existing contact.
  enum ActivityState: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// The ID is active (used recently and not deleted).
    case active // = 0

    /// The ID has not been used for a prolonged time (typically 3 months) and
    /// may have been abandoned. Such IDs can be marked as "inactive" in the
    /// client's contact database, and the user may be alerted to the fact that
    /// messages to this ID may not arrive (e.g. alert box, gray color in
    /// contact list etc.). An inactive ID can become active again at any time,
    /// so the client should keep checking it.
    case inactive // = 1

    /// ID has never been assigned, or it has been permanently deleted. Such IDs
    /// should be marked as "deleted" in the client's contact database, and no
    /// further messages should be sent or received from them. Since deletion is
    /// permanent, once an ID has been reported as invalid by the server, it
    /// should not be checked again in the future.
    case invalid // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .active
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .active
      case 1: self = .inactive
      case 2: self = .invalid
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .active: return 0
      case .inactive: return 1
      case .invalid: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Contact synchronisation state
  ///
  /// Required towards a new device and for a new contact. Optional for an
  /// existing contact.
  ///
  /// These states are strict monotonic. When a downgrade is being detected,
  /// log the incident and ignore the update.
  enum SyncState: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// The contact data has not been imported and has not been edited by the
    /// user either.
    case initial // = 0

    /// The contact data has been imported (e.g. via a local address book and an
    /// identity link). In this state, subsequent contact synchronisations must
    /// not alter the contact's data.
    case imported // = 1

    /// The contact data has been edited by the user. In this state, subsequent
    /// contact synchronisations must not alter the contact's data.
    case custom // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .initial
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .initial
      case 1: self = .imported
      case 2: self = .custom
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .initial: return 0
      case .imported: return 1
      case .custom: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// _Read_ receipt policy override for this contact
  ///
  /// Required towards a new device and for a new contact. Optional for an
  /// existing contact.
  struct ReadReceiptPolicyOverride {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var override: Sync_Contact.ReadReceiptPolicyOverride.OneOf_Override? = nil

    /// Apply the _read_ receipt policy specified in the settings
    var `default`: Common_Unit {
      get {
        if case .default(let v)? = override {return v}
        return Common_Unit()
      }
      set {override = .default(newValue)}
    }

    /// Apply the following _read_ receipt policy
    var policy: Sync_ReadReceiptPolicy {
      get {
        if case .policy(let v)? = override {return v}
        return .sendReadReceipt
      }
      set {override = .policy(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Override: Equatable {
      /// Apply the _read_ receipt policy specified in the settings
      case `default`(Common_Unit)
      /// Apply the following _read_ receipt policy
      case policy(Sync_ReadReceiptPolicy)

    #if !swift(>=4.1)
      static func ==(lhs: Sync_Contact.ReadReceiptPolicyOverride.OneOf_Override, rhs: Sync_Contact.ReadReceiptPolicyOverride.OneOf_Override) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.default, .default): return {
          guard case .default(let l) = lhs, case .default(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.policy, .policy): return {
          guard case .policy(let l) = lhs, case .policy(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    init() {}
  }

  /// Typing indicator policy override for this contact
  ///
  /// Required towards a new device and for a new contact. Optional for an
  /// existing contact.
  struct TypingIndicatorPolicyOverride {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var override: Sync_Contact.TypingIndicatorPolicyOverride.OneOf_Override? = nil

    /// Apply the typing indicator policy specified in the settings
    var `default`: Common_Unit {
      get {
        if case .default(let v)? = override {return v}
        return Common_Unit()
      }
      set {override = .default(newValue)}
    }

    /// Apply the following typing indicator policy
    var policy: Sync_TypingIndicatorPolicy {
      get {
        if case .policy(let v)? = override {return v}
        return .sendTypingIndicator
      }
      set {override = .policy(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Override: Equatable {
      /// Apply the typing indicator policy specified in the settings
      case `default`(Common_Unit)
      /// Apply the following typing indicator policy
      case policy(Sync_TypingIndicatorPolicy)

    #if !swift(>=4.1)
      static func ==(lhs: Sync_Contact.TypingIndicatorPolicyOverride.OneOf_Override, rhs: Sync_Contact.TypingIndicatorPolicyOverride.OneOf_Override) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.default, .default): return {
          guard case .default(let l) = lhs, case .default(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.policy, .policy): return {
          guard case .policy(let l) = lhs, case .policy(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    init() {}
  }

  /// Notification trigger policy for the contact
  ///
  /// Required towards a new device and for a new contact. Optional for an
  /// existing contact.
  struct NotificationTriggerPolicyOverride {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var override: Sync_Contact.NotificationTriggerPolicyOverride.OneOf_Override? = nil

    /// Apply the trigger policy specified in the settings (i.e. trigger on
    /// every _conversation_ message).
    var `default`: Common_Unit {
      get {
        if case .default(let v)? = override {return v}
        return Common_Unit()
      }
      set {override = .default(newValue)}
    }

    /// Apply the following notification trigger policy
    var policy: Sync_Contact.NotificationTriggerPolicyOverride.Policy {
      get {
        if case .policy(let v)? = override {return v}
        return Sync_Contact.NotificationTriggerPolicyOverride.Policy()
      }
      set {override = .policy(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Override: Equatable {
      /// Apply the trigger policy specified in the settings (i.e. trigger on
      /// every _conversation_ message).
      case `default`(Common_Unit)
      /// Apply the following notification trigger policy
      case policy(Sync_Contact.NotificationTriggerPolicyOverride.Policy)

    #if !swift(>=4.1)
      static func ==(lhs: Sync_Contact.NotificationTriggerPolicyOverride.OneOf_Override, rhs: Sync_Contact.NotificationTriggerPolicyOverride.OneOf_Override) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.default, .default): return {
          guard case .default(let l) = lhs, case .default(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.policy, .policy): return {
          guard case .policy(let l) = lhs, case .policy(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    struct Policy {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var policy: Sync_Contact.NotificationTriggerPolicyOverride.Policy.NotificationTriggerPolicy = .never

      /// Unix-ish timestamp in milliseconds when the provided policy should
      /// expire and fall back to the default. If not provided, the policy does
      /// not expire.
      var expiresAt: UInt64 {
        get {return _expiresAt ?? 0}
        set {_expiresAt = newValue}
      }
      /// Returns true if `expiresAt` has been explicitly set.
      var hasExpiresAt: Bool {return self._expiresAt != nil}
      /// Clears the value of `expiresAt`. Subsequent reads from it will return its default value.
      mutating func clearExpiresAt() {self._expiresAt = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      /// Apply the following notification trigger policy
      enum NotificationTriggerPolicy: SwiftProtobuf.Enum {
        typealias RawValue = Int

        /// Never trigger a notification message.
        case never // = 0
        case UNRECOGNIZED(Int)

        init() {
          self = .never
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .never
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .never: return 0
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      init() {}

      fileprivate var _expiresAt: UInt64? = nil
    }

    init() {}
  }

  /// Notification sound policy for the contact
  ///
  /// Required towards a new device and for a new contact. Optional for an
  /// existing contact.
  ///
  /// Custom sounds are not reflected but are to be (re-)applied in case the
  /// policy is _default_.
  struct NotificationSoundPolicyOverride {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var override: Sync_Contact.NotificationSoundPolicyOverride.OneOf_Override? = nil

    /// Apply the notification sound policy specified in the settings (i.e.
    /// always emit a sound when notifying of a _conversation_ message).
    var `default`: Common_Unit {
      get {
        if case .default(let v)? = override {return v}
        return Common_Unit()
      }
      set {override = .default(newValue)}
    }

    /// Apply the following notification sound policy
    var policy: Sync_NotificationSoundPolicy {
      get {
        if case .policy(let v)? = override {return v}
        return .muted
      }
      set {override = .policy(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Override: Equatable {
      /// Apply the notification sound policy specified in the settings (i.e.
      /// always emit a sound when notifying of a _conversation_ message).
      case `default`(Common_Unit)
      /// Apply the following notification sound policy
      case policy(Sync_NotificationSoundPolicy)

    #if !swift(>=4.1)
      static func ==(lhs: Sync_Contact.NotificationSoundPolicyOverride.OneOf_Override, rhs: Sync_Contact.NotificationSoundPolicyOverride.OneOf_Override) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.default, .default): return {
          guard case .default(let l) = lhs, case .default(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.policy, .policy): return {
          guard case .policy(let l) = lhs, case .policy(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    init() {}
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Sync_Contact.VerificationLevel: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_Contact.VerificationLevel] = [
    .unverified,
    .serverVerified,
    .fullyVerified,
  ]
}

extension Sync_Contact.WorkVerificationLevel: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_Contact.WorkVerificationLevel] = [
    .none,
    .workSubscriptionVerified,
  ]
}

extension Sync_Contact.IdentityType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_Contact.IdentityType] = [
    .regular,
    .work,
  ]
}

extension Sync_Contact.AcquaintanceLevel: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_Contact.AcquaintanceLevel] = [
    .direct,
    .group,
  ]
}

extension Sync_Contact.ActivityState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_Contact.ActivityState] = [
    .active,
    .inactive,
    .invalid,
  ]
}

extension Sync_Contact.SyncState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_Contact.SyncState] = [
    .initial,
    .imported,
    .custom,
  ]
}

extension Sync_Contact.NotificationTriggerPolicyOverride.Policy.NotificationTriggerPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_Contact.NotificationTriggerPolicyOverride.Policy.NotificationTriggerPolicy] = [
    .never,
  ]
}

#endif  // swift(>=4.2)

/// Threema contacts associated to a group.
struct Sync_Group {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique group identity
  ///
  /// Always required.
  var groupIdentity: Common_GroupIdentity {
    get {return _groupIdentity ?? Common_GroupIdentity()}
    set {_groupIdentity = newValue}
  }
  /// Returns true if `groupIdentity` has been explicitly set.
  var hasGroupIdentity: Bool {return self._groupIdentity != nil}
  /// Clears the value of `groupIdentity`. Subsequent reads from it will return its default value.
  mutating func clearGroupIdentity() {self._groupIdentity = nil}

  /// Name of the group
  ///
  /// Required towards a new device and for a new group. Optional for an
  /// existing group.
  ///
  /// An empty string is valid. In such a case, the display name of the
  /// group is the list of its members.
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// Unix-ish timestamp in milliseconds when the group has been created locally
  ///
  /// Required towards a new device and for a new group. Optional for an
  /// existing group.
  var createdAt: UInt64 {
    get {return _createdAt ?? 0}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var userState: Sync_Group.UserState {
    get {return _userState ?? .member}
    set {_userState = newValue}
  }
  /// Returns true if `userState` has been explicitly set.
  var hasUserState: Bool {return self._userState != nil}
  /// Clears the value of `userState`. Subsequent reads from it will return its default value.
  mutating func clearUserState() {self._userState = nil}

  var notificationTriggerPolicyOverride: Sync_Group.NotificationTriggerPolicyOverride {
    get {return _notificationTriggerPolicyOverride ?? Sync_Group.NotificationTriggerPolicyOverride()}
    set {_notificationTriggerPolicyOverride = newValue}
  }
  /// Returns true if `notificationTriggerPolicyOverride` has been explicitly set.
  var hasNotificationTriggerPolicyOverride: Bool {return self._notificationTriggerPolicyOverride != nil}
  /// Clears the value of `notificationTriggerPolicyOverride`. Subsequent reads from it will return its default value.
  mutating func clearNotificationTriggerPolicyOverride() {self._notificationTriggerPolicyOverride = nil}

  var notificationSoundPolicyOverride: Sync_Group.NotificationSoundPolicyOverride {
    get {return _notificationSoundPolicyOverride ?? Sync_Group.NotificationSoundPolicyOverride()}
    set {_notificationSoundPolicyOverride = newValue}
  }
  /// Returns true if `notificationSoundPolicyOverride` has been explicitly set.
  var hasNotificationSoundPolicyOverride: Bool {return self._notificationSoundPolicyOverride != nil}
  /// Clears the value of `notificationSoundPolicyOverride`. Subsequent reads from it will return its default value.
  mutating func clearNotificationSoundPolicyOverride() {self._notificationSoundPolicyOverride = nil}

  /// Group's profile picture as received from the group's creator
  ///
  /// Always optional.
  var profilePicture: Common_DeltaImage {
    get {return _profilePicture ?? Common_DeltaImage()}
    set {_profilePicture = newValue}
  }
  /// Returns true if `profilePicture` has been explicitly set.
  var hasProfilePicture: Bool {return self._profilePicture != nil}
  /// Clears the value of `profilePicture`. Subsequent reads from it will return its default value.
  mutating func clearProfilePicture() {self._profilePicture = nil}

  /// Group members (**NOT** including the user itself)
  ///
  /// Required towards a new device and for a new group. Optional for an existing
  /// group.
  ///
  /// The concrete semantic of this list depends on the current `user_state`:
  ///
  /// - `MEMBER`: It contains a list of all **current** group members (with the
  ///   user itself implicitly added).
  /// - `KICKED`/`LEFT`: It contains a list of all **previous** group members up
  ///   to that event. If the list is empty, the group must not be visible in the
  ///   UI.
  ///
  /// An empty list is valid.
  var memberIdentities: Common_Identities {
    get {return _memberIdentities ?? Common_Identities()}
    set {_memberIdentities = newValue}
  }
  /// Returns true if `memberIdentities` has been explicitly set.
  var hasMemberIdentities: Bool {return self._memberIdentities != nil}
  /// Clears the value of `memberIdentities`. Subsequent reads from it will return its default value.
  mutating func clearMemberIdentities() {self._memberIdentities = nil}

  /// Conversation category of the group
  ///
  /// Required towards a new device and for a new group. Optional for an
  /// existing group.
  var conversationCategory: Sync_ConversationCategory {
    get {return _conversationCategory ?? .default}
    set {_conversationCategory = newValue}
  }
  /// Returns true if `conversationCategory` has been explicitly set.
  var hasConversationCategory: Bool {return self._conversationCategory != nil}
  /// Clears the value of `conversationCategory`. Subsequent reads from it will return its default value.
  mutating func clearConversationCategory() {self._conversationCategory = nil}

  /// Conversation visbility of the group
  ///
  /// Required towards a new device and for a new group. Optional for an
  /// existing group.
  var conversationVisibility: Sync_ConversationVisibility {
    get {return _conversationVisibility ?? .normal}
    set {_conversationVisibility = newValue}
  }
  /// Returns true if `conversationVisibility` has been explicitly set.
  var hasConversationVisibility: Bool {return self._conversationVisibility != nil}
  /// Clears the value of `conversationVisibility`. Subsequent reads from it will return its default value.
  mutating func clearConversationVisibility() {self._conversationVisibility = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The user's state within the group
  ///
  /// Required towards a new device and for a new group. Optional for an
  /// existing group.
  enum UserState: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// The user is a member (or creator) of the group.
    case member // = 0

    /// The user has been kicked from the group. Implies that the group has been
    /// marked as _left_.
    case kicked // = 1

    /// The user left the group. Implies that the group has been marked as
    /// _left_.
    case left // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .member
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .member
      case 1: self = .kicked
      case 2: self = .left
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .member: return 0
      case .kicked: return 1
      case .left: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Notification trigger policy for the group
  ///
  /// Required towards a new device and for a new group. Optional for an
  /// existing group.
  struct NotificationTriggerPolicyOverride {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var override: Sync_Group.NotificationTriggerPolicyOverride.OneOf_Override? = nil

    /// Apply the trigger policy specified in the settings (i.e. trigger on
    /// every _conversation_ message).
    var `default`: Common_Unit {
      get {
        if case .default(let v)? = override {return v}
        return Common_Unit()
      }
      set {override = .default(newValue)}
    }

    /// Apply the following notification trigger policy
    var policy: Sync_Group.NotificationTriggerPolicyOverride.Policy {
      get {
        if case .policy(let v)? = override {return v}
        return Sync_Group.NotificationTriggerPolicyOverride.Policy()
      }
      set {override = .policy(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Override: Equatable {
      /// Apply the trigger policy specified in the settings (i.e. trigger on
      /// every _conversation_ message).
      case `default`(Common_Unit)
      /// Apply the following notification trigger policy
      case policy(Sync_Group.NotificationTriggerPolicyOverride.Policy)

    #if !swift(>=4.1)
      static func ==(lhs: Sync_Group.NotificationTriggerPolicyOverride.OneOf_Override, rhs: Sync_Group.NotificationTriggerPolicyOverride.OneOf_Override) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.default, .default): return {
          guard case .default(let l) = lhs, case .default(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.policy, .policy): return {
          guard case .policy(let l) = lhs, case .policy(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    struct Policy {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var policy: Sync_Group.NotificationTriggerPolicyOverride.Policy.NotificationTriggerPolicy = .mentioned

      /// Unix-ish timestamp in milliseconds when the provided policy should
      /// expire and fall back to the default. If not provided, the policy does
      /// not expire.
      var expiresAt: UInt64 {
        get {return _expiresAt ?? 0}
        set {_expiresAt = newValue}
      }
      /// Returns true if `expiresAt` has been explicitly set.
      var hasExpiresAt: Bool {return self._expiresAt != nil}
      /// Clears the value of `expiresAt`. Subsequent reads from it will return its default value.
      mutating func clearExpiresAt() {self._expiresAt = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      /// Apply the following notification trigger policy
      enum NotificationTriggerPolicy: SwiftProtobuf.Enum {
        typealias RawValue = Int

        /// Only trigger a notification if mentioned in a _conversation_ message.
        case mentioned // = 0

        /// Never trigger a notification message.
        case never // = 1
        case UNRECOGNIZED(Int)

        init() {
          self = .mentioned
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 0: self = .mentioned
          case 1: self = .never
          default: self = .UNRECOGNIZED(rawValue)
          }
        }

        var rawValue: Int {
          switch self {
          case .mentioned: return 0
          case .never: return 1
          case .UNRECOGNIZED(let i): return i
          }
        }

      }

      init() {}

      fileprivate var _expiresAt: UInt64? = nil
    }

    init() {}
  }

  /// Notification sound policy for the group
  ///
  /// Required towards a new device and for a new group. Optional for an existing
  /// group.
  ///
  /// Custom sounds are not reflected but are to be (re-)applied in case the
  /// policy is _default_.
  struct NotificationSoundPolicyOverride {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var override: Sync_Group.NotificationSoundPolicyOverride.OneOf_Override? = nil

    /// Apply the notification sound policy specified in the settings (i.e.
    /// always emit a sound when notifying of a _conversation_ message).
    var `default`: Common_Unit {
      get {
        if case .default(let v)? = override {return v}
        return Common_Unit()
      }
      set {override = .default(newValue)}
    }

    /// Apply the following notification sound policy
    var policy: Sync_NotificationSoundPolicy {
      get {
        if case .policy(let v)? = override {return v}
        return .muted
      }
      set {override = .policy(newValue)}
    }

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum OneOf_Override: Equatable {
      /// Apply the notification sound policy specified in the settings (i.e.
      /// always emit a sound when notifying of a _conversation_ message).
      case `default`(Common_Unit)
      /// Apply the following notification sound policy
      case policy(Sync_NotificationSoundPolicy)

    #if !swift(>=4.1)
      static func ==(lhs: Sync_Group.NotificationSoundPolicyOverride.OneOf_Override, rhs: Sync_Group.NotificationSoundPolicyOverride.OneOf_Override) -> Bool {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch (lhs, rhs) {
        case (.default, .default): return {
          guard case .default(let l) = lhs, case .default(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        case (.policy, .policy): return {
          guard case .policy(let l) = lhs, case .policy(let r) = rhs else { preconditionFailure() }
          return l == r
        }()
        default: return false
        }
      }
    #endif
    }

    init() {}
  }

  init() {}

  fileprivate var _groupIdentity: Common_GroupIdentity? = nil
  fileprivate var _name: String? = nil
  fileprivate var _createdAt: UInt64? = nil
  fileprivate var _userState: Sync_Group.UserState? = nil
  fileprivate var _notificationTriggerPolicyOverride: Sync_Group.NotificationTriggerPolicyOverride? = nil
  fileprivate var _notificationSoundPolicyOverride: Sync_Group.NotificationSoundPolicyOverride? = nil
  fileprivate var _profilePicture: Common_DeltaImage? = nil
  fileprivate var _memberIdentities: Common_Identities? = nil
  fileprivate var _conversationCategory: Sync_ConversationCategory? = nil
  fileprivate var _conversationVisibility: Sync_ConversationVisibility? = nil
}

#if swift(>=4.2)

extension Sync_Group.UserState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_Group.UserState] = [
    .member,
    .kicked,
    .left,
  ]
}

extension Sync_Group.NotificationTriggerPolicyOverride.Policy.NotificationTriggerPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_Group.NotificationTriggerPolicyOverride.Policy.NotificationTriggerPolicy] = [
    .mentioned,
    .never,
  ]
}

#endif  // swift(>=4.2)

/// Threema contacts associated to a distribution list.
struct Sync_DistributionList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique ID of the distribution list
  ///
  /// Always required.
  var distributionListID: UInt64 = 0

  /// Name of the distribution list
  ///
  /// Required towards a new device and for a new distribution list. Optional
  /// for an existing distribution list.
  ///
  /// An empty string is valid. In such a case, the display name of the
  /// distribution list is the list of its members.
  var name: String {
    get {return _name ?? String()}
    set {_name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return self._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {self._name = nil}

  /// Unix-ish timestamp in milliseconds when the group has been created
  ///
  /// Required towards a new device and for a new distribution list. Optional
  /// for an existing distribution list.
  var createdAt: UInt64 {
    get {return _createdAt ?? 0}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  /// Distribution list members
  ///
  /// Required towards a new device and for a new distribution list. Optional
  /// for an existing distribution list.
  ///
  /// An empty list is **not** valid. Clearing all members should be prevented
  /// by the UI.
  var memberIdentities: Common_Identities {
    get {return _memberIdentities ?? Common_Identities()}
    set {_memberIdentities = newValue}
  }
  /// Returns true if `memberIdentities` has been explicitly set.
  var hasMemberIdentities: Bool {return self._memberIdentities != nil}
  /// Clears the value of `memberIdentities`. Subsequent reads from it will return its default value.
  mutating func clearMemberIdentities() {self._memberIdentities = nil}

  /// Conversation category of the distribution list
  ///
  /// Required towards a new device and for a new distribution list. Optional
  /// for an existing distribution list.
  var conversationCategory: Sync_ConversationCategory {
    get {return _conversationCategory ?? .default}
    set {_conversationCategory = newValue}
  }
  /// Returns true if `conversationCategory` has been explicitly set.
  var hasConversationCategory: Bool {return self._conversationCategory != nil}
  /// Clears the value of `conversationCategory`. Subsequent reads from it will return its default value.
  mutating func clearConversationCategory() {self._conversationCategory = nil}

  /// Conversation visbility of the distribution list
  ///
  /// Required towards a new device and for a new distribution list. Optional
  /// for an existing distribution list.
  var conversationVisibility: Sync_ConversationVisibility {
    get {return _conversationVisibility ?? .normal}
    set {_conversationVisibility = newValue}
  }
  /// Returns true if `conversationVisibility` has been explicitly set.
  var hasConversationVisibility: Bool {return self._conversationVisibility != nil}
  /// Clears the value of `conversationVisibility`. Subsequent reads from it will return its default value.
  mutating func clearConversationVisibility() {self._conversationVisibility = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _name: String? = nil
  fileprivate var _createdAt: UInt64? = nil
  fileprivate var _memberIdentities: Common_Identities? = nil
  fileprivate var _conversationCategory: Sync_ConversationCategory? = nil
  fileprivate var _conversationVisibility: Sync_ConversationVisibility? = nil
}

/// App settings
struct Sync_Settings {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var contactSyncPolicy: Sync_Settings.ContactSyncPolicy {
    get {return _contactSyncPolicy ?? .notSynced}
    set {_contactSyncPolicy = newValue}
  }
  /// Returns true if `contactSyncPolicy` has been explicitly set.
  var hasContactSyncPolicy: Bool {return self._contactSyncPolicy != nil}
  /// Clears the value of `contactSyncPolicy`. Subsequent reads from it will return its default value.
  mutating func clearContactSyncPolicy() {self._contactSyncPolicy = nil}

  var unknownContactPolicy: Sync_Settings.UnknownContactPolicy {
    get {return _unknownContactPolicy ?? .allowUnknown}
    set {_unknownContactPolicy = newValue}
  }
  /// Returns true if `unknownContactPolicy` has been explicitly set.
  var hasUnknownContactPolicy: Bool {return self._unknownContactPolicy != nil}
  /// Clears the value of `unknownContactPolicy`. Subsequent reads from it will return its default value.
  mutating func clearUnknownContactPolicy() {self._unknownContactPolicy = nil}

  /// _Read_ receipt policy (when an unread message has been read)
  ///
  /// Required towards a new device. Optional otherwise.
  var readReceiptPolicy: Sync_ReadReceiptPolicy {
    get {return _readReceiptPolicy ?? .sendReadReceipt}
    set {_readReceiptPolicy = newValue}
  }
  /// Returns true if `readReceiptPolicy` has been explicitly set.
  var hasReadReceiptPolicy: Bool {return self._readReceiptPolicy != nil}
  /// Clears the value of `readReceiptPolicy`. Subsequent reads from it will return its default value.
  mutating func clearReadReceiptPolicy() {self._readReceiptPolicy = nil}

  /// Typing indicator policy (signal _currently typing_)
  ///
  /// Required towards a new device. Optional otherwise.
  var typingIndicatorPolicy: Sync_TypingIndicatorPolicy {
    get {return _typingIndicatorPolicy ?? .sendTypingIndicator}
    set {_typingIndicatorPolicy = newValue}
  }
  /// Returns true if `typingIndicatorPolicy` has been explicitly set.
  var hasTypingIndicatorPolicy: Bool {return self._typingIndicatorPolicy != nil}
  /// Clears the value of `typingIndicatorPolicy`. Subsequent reads from it will return its default value.
  mutating func clearTypingIndicatorPolicy() {self._typingIndicatorPolicy = nil}

  var callPolicy: Sync_Settings.CallPolicy {
    get {return _callPolicy ?? .allowCall}
    set {_callPolicy = newValue}
  }
  /// Returns true if `callPolicy` has been explicitly set.
  var hasCallPolicy: Bool {return self._callPolicy != nil}
  /// Clears the value of `callPolicy`. Subsequent reads from it will return its default value.
  mutating func clearCallPolicy() {self._callPolicy = nil}

  var callConnectionPolity: Sync_Settings.CallConnectionPolicy {
    get {return _callConnectionPolity ?? .allowDirect}
    set {_callConnectionPolity = newValue}
  }
  /// Returns true if `callConnectionPolity` has been explicitly set.
  var hasCallConnectionPolity: Bool {return self._callConnectionPolity != nil}
  /// Clears the value of `callConnectionPolity`. Subsequent reads from it will return its default value.
  mutating func clearCallConnectionPolity() {self._callConnectionPolity = nil}

  var screenshotPolicy: Sync_Settings.ScreenshotPolicy {
    get {return _screenshotPolicy ?? .allowScreenshot}
    set {_screenshotPolicy = newValue}
  }
  /// Returns true if `screenshotPolicy` has been explicitly set.
  var hasScreenshotPolicy: Bool {return self._screenshotPolicy != nil}
  /// Clears the value of `screenshotPolicy`. Subsequent reads from it will return its default value.
  mutating func clearScreenshotPolicy() {self._screenshotPolicy = nil}

  var keyboardDataCollectionPolicy: Sync_Settings.KeyboardDataCollectionPolicy {
    get {return _keyboardDataCollectionPolicy ?? .allowDataCollection}
    set {_keyboardDataCollectionPolicy = newValue}
  }
  /// Returns true if `keyboardDataCollectionPolicy` has been explicitly set.
  var hasKeyboardDataCollectionPolicy: Bool {return self._keyboardDataCollectionPolicy != nil}
  /// Clears the value of `keyboardDataCollectionPolicy`. Subsequent reads from it will return its default value.
  mutating func clearKeyboardDataCollectionPolicy() {self._keyboardDataCollectionPolicy = nil}

  /// List of Threema IDs whose messages are blocked
  ///
  /// Required towards a new device. Optional otherwise.
  ///
  /// An empty list is valid.
  var blockedIdentities: Common_Identities {
    get {return _blockedIdentities ?? Common_Identities()}
    set {_blockedIdentities = newValue}
  }
  /// Returns true if `blockedIdentities` has been explicitly set.
  var hasBlockedIdentities: Bool {return self._blockedIdentities != nil}
  /// Clears the value of `blockedIdentities`. Subsequent reads from it will return its default value.
  mutating func clearBlockedIdentities() {self._blockedIdentities = nil}

  /// Threema IDs to be excluded when syncing the contact list
  ///
  /// Required towards a new device. Optional otherwise.
  ///
  /// An empty list is valid.
  var excludeFromSyncIdentities: Common_Identities {
    get {return _excludeFromSyncIdentities ?? Common_Identities()}
    set {_excludeFromSyncIdentities = newValue}
  }
  /// Returns true if `excludeFromSyncIdentities` has been explicitly set.
  var hasExcludeFromSyncIdentities: Bool {return self._excludeFromSyncIdentities != nil}
  /// Clears the value of `excludeFromSyncIdentities`. Subsequent reads from it will return its default value.
  mutating func clearExcludeFromSyncIdentities() {self._excludeFromSyncIdentities = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Contact synchronisation policy
  ///
  /// Required towards a new device. Optional otherwise.
  enum ContactSyncPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Not synced
    case notSynced // = 0

    /// Synced
    case sync // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .notSynced
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .notSynced
      case 1: self = .sync
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .notSynced: return 0
      case .sync: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Unknown contacts policy
  ///
  /// Required towards a new device. Optional otherwise.
  enum UnknownContactPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Allowed to contact the user
    case allowUnknown // = 0

    /// Will be blocked by the user
    case blockUnknown // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowUnknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowUnknown
      case 1: self = .blockUnknown
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowUnknown: return 0
      case .blockUnknown: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Threema Call policy
  ///
  /// Required towards a new device. Optional otherwise.
  enum CallPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Allow creating/receiving Threema Calls
    case allowCall // = 0

    /// Denied from creating/receiving any Threema Calls
    case denyCall // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowCall
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowCall
      case 1: self = .denyCall
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowCall: return 0
      case .denyCall: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Threema Call connection policy
  ///
  /// Required towards a new device. Optional otherwise.
  enum CallConnectionPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Allow direct (peer-to-peer) connections for Threema Calls
    case allowDirect // = 0

    /// Require relayed connections for Threema Calls
    case requireRelay // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowDirect
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowDirect
      case 1: self = .requireRelay
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowDirect: return 0
      case .requireRelay: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Screenshot policy
  ///
  /// Required towards a new device. Optional otherwise.
  enum ScreenshotPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Allow taking screenshots
    case allowScreenshot // = 0

    /// Deny taking screenshots, if possible
    case denyScreenshot // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowScreenshot
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowScreenshot
      case 1: self = .denyScreenshot
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowScreenshot: return 0
      case .denyScreenshot: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  /// Keyboard data collection policy (e.g. for personalised suggestions)
  ///
  /// Required towards a new device. Optional otherwise.
  enum KeyboardDataCollectionPolicy: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Allow keyboard input data to be collected
    case allowDataCollection // = 0

    /// Deny collecting of keyboard input data
    case denyDataCollection // = 1
    case UNRECOGNIZED(Int)

    init() {
      self = .allowDataCollection
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .allowDataCollection
      case 1: self = .denyDataCollection
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .allowDataCollection: return 0
      case .denyDataCollection: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _contactSyncPolicy: Sync_Settings.ContactSyncPolicy? = nil
  fileprivate var _unknownContactPolicy: Sync_Settings.UnknownContactPolicy? = nil
  fileprivate var _readReceiptPolicy: Sync_ReadReceiptPolicy? = nil
  fileprivate var _typingIndicatorPolicy: Sync_TypingIndicatorPolicy? = nil
  fileprivate var _callPolicy: Sync_Settings.CallPolicy? = nil
  fileprivate var _callConnectionPolity: Sync_Settings.CallConnectionPolicy? = nil
  fileprivate var _screenshotPolicy: Sync_Settings.ScreenshotPolicy? = nil
  fileprivate var _keyboardDataCollectionPolicy: Sync_Settings.KeyboardDataCollectionPolicy? = nil
  fileprivate var _blockedIdentities: Common_Identities? = nil
  fileprivate var _excludeFromSyncIdentities: Common_Identities? = nil
}

#if swift(>=4.2)

extension Sync_Settings.ContactSyncPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_Settings.ContactSyncPolicy] = [
    .notSynced,
    .sync,
  ]
}

extension Sync_Settings.UnknownContactPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_Settings.UnknownContactPolicy] = [
    .allowUnknown,
    .blockUnknown,
  ]
}

extension Sync_Settings.CallPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_Settings.CallPolicy] = [
    .allowCall,
    .denyCall,
  ]
}

extension Sync_Settings.CallConnectionPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_Settings.CallConnectionPolicy] = [
    .allowDirect,
    .requireRelay,
  ]
}

extension Sync_Settings.ScreenshotPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_Settings.ScreenshotPolicy] = [
    .allowScreenshot,
    .denyScreenshot,
  ]
}

extension Sync_Settings.KeyboardDataCollectionPolicy: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Sync_Settings.KeyboardDataCollectionPolicy] = [
    .allowDataCollection,
    .denyDataCollection,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "sync"

extension Sync_ReadReceiptPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SEND_READ_RECEIPT"),
    1: .same(proto: "DONT_SEND_READ_RECEIPT"),
  ]
}

extension Sync_TypingIndicatorPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SEND_TYPING_INDICATOR"),
    1: .same(proto: "DONT_SEND_TYPING_INDICATOR"),
  ]
}

extension Sync_NotificationSoundPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MUTED"),
  ]
}

extension Sync_ConversationVisibility: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NORMAL"),
    1: .same(proto: "ARCHIVED"),
    2: .same(proto: "PINNED"),
  ]
}

extension Sync_ConversationCategory: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "PROTECTED"),
  ]
}

extension Sync_MdmParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MdmParameters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "license_username"),
    2: .standard(proto: "license_password"),
    3: .same(proto: "nickname"),
    4: .standard(proto: "first_name"),
    5: .standard(proto: "last_name"),
    6: .standard(proto: "customer_specific_id"),
    7: .same(proto: "category"),
    8: .standard(proto: "linked_email"),
    9: .standard(proto: "linked_phone"),
    10: .standard(proto: "identity_restore"),
    11: .standard(proto: "identity_restore_password"),
    12: .standard(proto: "threema_safe_policy"),
    13: .standard(proto: "threema_safe_password"),
    14: .standard(proto: "threema_safe_password_pattern"),
    15: .standard(proto: "threema_safe_password_pattern_error_message"),
    16: .standard(proto: "threema_safe_server_url"),
    17: .standard(proto: "threema_safe_server_username"),
    18: .standard(proto: "threema_safe_server_password"),
    19: .standard(proto: "threema_safe_restore_policy"),
    20: .standard(proto: "threema_safe_restore_identity"),
    21: .standard(proto: "override_policy"),
    22: .standard(proto: "contact_sync_policy"),
    23: .standard(proto: "inactive_identity_display_policy"),
    24: .standard(proto: "unknown_contact_policy"),
    25: .standard(proto: "auto_save_media_policy"),
    26: .standard(proto: "screenshot_policy"),
    27: .standard(proto: "add_contact_policy"),
    28: .standard(proto: "chat_export_policy"),
    29: .standard(proto: "backup_policy"),
    30: .standard(proto: "identity_export_policy"),
    31: .standard(proto: "data_backup_policy"),
    32: .standard(proto: "system_backup_policy"),
    33: .standard(proto: "message_preview_policy"),
    34: .standard(proto: "profile_picture_share_policy"),
    35: .standard(proto: "call_policy"),
    36: .standard(proto: "setup_wizard_policy"),
    37: .standard(proto: "create_group_policy"),
    38: .standard(proto: "share_media_policy"),
  ]

  fileprivate class _StorageClass {
    var _licenseUsername: String? = nil
    var _licensePassword: String? = nil
    var _nickname: String? = nil
    var _firstName: String? = nil
    var _lastName: String? = nil
    var _customerSpecificID: String? = nil
    var _category: String? = nil
    var _linkedEmail: String? = nil
    var _linkedPhone: String? = nil
    var _identityRestore: String? = nil
    var _identityRestorePassword: String? = nil
    var _threemaSafePolicy: Sync_MdmParameters.ThreemaSafePolicy? = nil
    var _threemaSafePassword: String? = nil
    var _threemaSafePasswordPattern: String? = nil
    var _threemaSafePasswordPatternErrorMessage: String? = nil
    var _threemaSafeServerURL: String? = nil
    var _threemaSafeServerUsername: String? = nil
    var _threemaSafeServerPassword: String? = nil
    var _threemaSafeRestorePolicy: Sync_MdmParameters.ThreemaSafeRestorePolicy? = nil
    var _threemaSafeRestoreIdentity: String? = nil
    var _overridePolicy: Sync_MdmParameters.OverridePolicy? = nil
    var _contactSyncPolicy: Sync_MdmParameters.ContactSyncPolicy? = nil
    var _inactiveIdentityDisplayPolicy: Sync_MdmParameters.InactiveIdentityDisplayPolicy? = nil
    var _unknownContactPolicy: Sync_MdmParameters.UnknownContactPolicy? = nil
    var _autoSaveMediaPolicy: Sync_MdmParameters.AutoSaveMediaPolicy? = nil
    var _screenshotPolicy: Sync_MdmParameters.ScreenshotPolicy? = nil
    var _addContactPolicy: Sync_MdmParameters.AddContactPolicy? = nil
    var _chatExportPolicy: Sync_MdmParameters.ChatExportPolicy? = nil
    var _backupPolicy: Sync_MdmParameters.BackupPolicy? = nil
    var _identityExportPolicy: Sync_MdmParameters.IdentityExportPolicy? = nil
    var _dataBackupPolicy: Sync_MdmParameters.DataBackupPolicy? = nil
    var _systemBackupPolicy: Sync_MdmParameters.SystemBackupPolicy? = nil
    var _messagePreviewPolicy: Sync_MdmParameters.MessagePreviewPolicy? = nil
    var _profilePictureSharePolicy: Sync_MdmParameters.ProfilePictureSharePolicy? = nil
    var _callPolicy: Sync_MdmParameters.CallPolicy? = nil
    var _setupWizardPolicy: Sync_MdmParameters.SetupWizardPolicy? = nil
    var _createGroupPolicy: Sync_MdmParameters.CreateGroupPolicy? = nil
    var _shareMediaPolicy: Sync_MdmParameters.ShareMediaPolicy? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _licenseUsername = source._licenseUsername
      _licensePassword = source._licensePassword
      _nickname = source._nickname
      _firstName = source._firstName
      _lastName = source._lastName
      _customerSpecificID = source._customerSpecificID
      _category = source._category
      _linkedEmail = source._linkedEmail
      _linkedPhone = source._linkedPhone
      _identityRestore = source._identityRestore
      _identityRestorePassword = source._identityRestorePassword
      _threemaSafePolicy = source._threemaSafePolicy
      _threemaSafePassword = source._threemaSafePassword
      _threemaSafePasswordPattern = source._threemaSafePasswordPattern
      _threemaSafePasswordPatternErrorMessage = source._threemaSafePasswordPatternErrorMessage
      _threemaSafeServerURL = source._threemaSafeServerURL
      _threemaSafeServerUsername = source._threemaSafeServerUsername
      _threemaSafeServerPassword = source._threemaSafeServerPassword
      _threemaSafeRestorePolicy = source._threemaSafeRestorePolicy
      _threemaSafeRestoreIdentity = source._threemaSafeRestoreIdentity
      _overridePolicy = source._overridePolicy
      _contactSyncPolicy = source._contactSyncPolicy
      _inactiveIdentityDisplayPolicy = source._inactiveIdentityDisplayPolicy
      _unknownContactPolicy = source._unknownContactPolicy
      _autoSaveMediaPolicy = source._autoSaveMediaPolicy
      _screenshotPolicy = source._screenshotPolicy
      _addContactPolicy = source._addContactPolicy
      _chatExportPolicy = source._chatExportPolicy
      _backupPolicy = source._backupPolicy
      _identityExportPolicy = source._identityExportPolicy
      _dataBackupPolicy = source._dataBackupPolicy
      _systemBackupPolicy = source._systemBackupPolicy
      _messagePreviewPolicy = source._messagePreviewPolicy
      _profilePictureSharePolicy = source._profilePictureSharePolicy
      _callPolicy = source._callPolicy
      _setupWizardPolicy = source._setupWizardPolicy
      _createGroupPolicy = source._createGroupPolicy
      _shareMediaPolicy = source._shareMediaPolicy
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._licenseUsername) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._licensePassword) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._nickname) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._firstName) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._lastName) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._customerSpecificID) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._category) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._linkedEmail) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._linkedPhone) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._identityRestore) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._identityRestorePassword) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._threemaSafePolicy) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._threemaSafePassword) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._threemaSafePasswordPattern) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._threemaSafePasswordPatternErrorMessage) }()
        case 16: try { try decoder.decodeSingularStringField(value: &_storage._threemaSafeServerURL) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._threemaSafeServerUsername) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._threemaSafeServerPassword) }()
        case 19: try { try decoder.decodeSingularEnumField(value: &_storage._threemaSafeRestorePolicy) }()
        case 20: try { try decoder.decodeSingularStringField(value: &_storage._threemaSafeRestoreIdentity) }()
        case 21: try { try decoder.decodeSingularEnumField(value: &_storage._overridePolicy) }()
        case 22: try { try decoder.decodeSingularEnumField(value: &_storage._contactSyncPolicy) }()
        case 23: try { try decoder.decodeSingularEnumField(value: &_storage._inactiveIdentityDisplayPolicy) }()
        case 24: try { try decoder.decodeSingularEnumField(value: &_storage._unknownContactPolicy) }()
        case 25: try { try decoder.decodeSingularEnumField(value: &_storage._autoSaveMediaPolicy) }()
        case 26: try { try decoder.decodeSingularEnumField(value: &_storage._screenshotPolicy) }()
        case 27: try { try decoder.decodeSingularEnumField(value: &_storage._addContactPolicy) }()
        case 28: try { try decoder.decodeSingularEnumField(value: &_storage._chatExportPolicy) }()
        case 29: try { try decoder.decodeSingularEnumField(value: &_storage._backupPolicy) }()
        case 30: try { try decoder.decodeSingularEnumField(value: &_storage._identityExportPolicy) }()
        case 31: try { try decoder.decodeSingularEnumField(value: &_storage._dataBackupPolicy) }()
        case 32: try { try decoder.decodeSingularEnumField(value: &_storage._systemBackupPolicy) }()
        case 33: try { try decoder.decodeSingularEnumField(value: &_storage._messagePreviewPolicy) }()
        case 34: try { try decoder.decodeSingularEnumField(value: &_storage._profilePictureSharePolicy) }()
        case 35: try { try decoder.decodeSingularEnumField(value: &_storage._callPolicy) }()
        case 36: try { try decoder.decodeSingularEnumField(value: &_storage._setupWizardPolicy) }()
        case 37: try { try decoder.decodeSingularEnumField(value: &_storage._createGroupPolicy) }()
        case 38: try { try decoder.decodeSingularEnumField(value: &_storage._shareMediaPolicy) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._licenseUsername {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if let v = _storage._licensePassword {
        try visitor.visitSingularStringField(value: v, fieldNumber: 2)
      }
      if let v = _storage._nickname {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if let v = _storage._firstName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._lastName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._customerSpecificID {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if let v = _storage._category {
        try visitor.visitSingularStringField(value: v, fieldNumber: 7)
      }
      if let v = _storage._linkedEmail {
        try visitor.visitSingularStringField(value: v, fieldNumber: 8)
      }
      if let v = _storage._linkedPhone {
        try visitor.visitSingularStringField(value: v, fieldNumber: 9)
      }
      if let v = _storage._identityRestore {
        try visitor.visitSingularStringField(value: v, fieldNumber: 10)
      }
      if let v = _storage._identityRestorePassword {
        try visitor.visitSingularStringField(value: v, fieldNumber: 11)
      }
      if let v = _storage._threemaSafePolicy {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 12)
      }
      if let v = _storage._threemaSafePassword {
        try visitor.visitSingularStringField(value: v, fieldNumber: 13)
      }
      if let v = _storage._threemaSafePasswordPattern {
        try visitor.visitSingularStringField(value: v, fieldNumber: 14)
      }
      if let v = _storage._threemaSafePasswordPatternErrorMessage {
        try visitor.visitSingularStringField(value: v, fieldNumber: 15)
      }
      if let v = _storage._threemaSafeServerURL {
        try visitor.visitSingularStringField(value: v, fieldNumber: 16)
      }
      if let v = _storage._threemaSafeServerUsername {
        try visitor.visitSingularStringField(value: v, fieldNumber: 17)
      }
      if let v = _storage._threemaSafeServerPassword {
        try visitor.visitSingularStringField(value: v, fieldNumber: 18)
      }
      if let v = _storage._threemaSafeRestorePolicy {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 19)
      }
      if let v = _storage._threemaSafeRestoreIdentity {
        try visitor.visitSingularStringField(value: v, fieldNumber: 20)
      }
      if let v = _storage._overridePolicy {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 21)
      }
      if let v = _storage._contactSyncPolicy {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 22)
      }
      if let v = _storage._inactiveIdentityDisplayPolicy {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 23)
      }
      if let v = _storage._unknownContactPolicy {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 24)
      }
      if let v = _storage._autoSaveMediaPolicy {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 25)
      }
      if let v = _storage._screenshotPolicy {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 26)
      }
      if let v = _storage._addContactPolicy {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 27)
      }
      if let v = _storage._chatExportPolicy {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 28)
      }
      if let v = _storage._backupPolicy {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 29)
      }
      if let v = _storage._identityExportPolicy {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 30)
      }
      if let v = _storage._dataBackupPolicy {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 31)
      }
      if let v = _storage._systemBackupPolicy {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 32)
      }
      if let v = _storage._messagePreviewPolicy {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 33)
      }
      if let v = _storage._profilePictureSharePolicy {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 34)
      }
      if let v = _storage._callPolicy {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 35)
      }
      if let v = _storage._setupWizardPolicy {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 36)
      }
      if let v = _storage._createGroupPolicy {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 37)
      }
      if let v = _storage._shareMediaPolicy {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 38)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sync_MdmParameters, rhs: Sync_MdmParameters) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._licenseUsername != rhs_storage._licenseUsername {return false}
        if _storage._licensePassword != rhs_storage._licensePassword {return false}
        if _storage._nickname != rhs_storage._nickname {return false}
        if _storage._firstName != rhs_storage._firstName {return false}
        if _storage._lastName != rhs_storage._lastName {return false}
        if _storage._customerSpecificID != rhs_storage._customerSpecificID {return false}
        if _storage._category != rhs_storage._category {return false}
        if _storage._linkedEmail != rhs_storage._linkedEmail {return false}
        if _storage._linkedPhone != rhs_storage._linkedPhone {return false}
        if _storage._identityRestore != rhs_storage._identityRestore {return false}
        if _storage._identityRestorePassword != rhs_storage._identityRestorePassword {return false}
        if _storage._threemaSafePolicy != rhs_storage._threemaSafePolicy {return false}
        if _storage._threemaSafePassword != rhs_storage._threemaSafePassword {return false}
        if _storage._threemaSafePasswordPattern != rhs_storage._threemaSafePasswordPattern {return false}
        if _storage._threemaSafePasswordPatternErrorMessage != rhs_storage._threemaSafePasswordPatternErrorMessage {return false}
        if _storage._threemaSafeServerURL != rhs_storage._threemaSafeServerURL {return false}
        if _storage._threemaSafeServerUsername != rhs_storage._threemaSafeServerUsername {return false}
        if _storage._threemaSafeServerPassword != rhs_storage._threemaSafeServerPassword {return false}
        if _storage._threemaSafeRestorePolicy != rhs_storage._threemaSafeRestorePolicy {return false}
        if _storage._threemaSafeRestoreIdentity != rhs_storage._threemaSafeRestoreIdentity {return false}
        if _storage._overridePolicy != rhs_storage._overridePolicy {return false}
        if _storage._contactSyncPolicy != rhs_storage._contactSyncPolicy {return false}
        if _storage._inactiveIdentityDisplayPolicy != rhs_storage._inactiveIdentityDisplayPolicy {return false}
        if _storage._unknownContactPolicy != rhs_storage._unknownContactPolicy {return false}
        if _storage._autoSaveMediaPolicy != rhs_storage._autoSaveMediaPolicy {return false}
        if _storage._screenshotPolicy != rhs_storage._screenshotPolicy {return false}
        if _storage._addContactPolicy != rhs_storage._addContactPolicy {return false}
        if _storage._chatExportPolicy != rhs_storage._chatExportPolicy {return false}
        if _storage._backupPolicy != rhs_storage._backupPolicy {return false}
        if _storage._identityExportPolicy != rhs_storage._identityExportPolicy {return false}
        if _storage._dataBackupPolicy != rhs_storage._dataBackupPolicy {return false}
        if _storage._systemBackupPolicy != rhs_storage._systemBackupPolicy {return false}
        if _storage._messagePreviewPolicy != rhs_storage._messagePreviewPolicy {return false}
        if _storage._profilePictureSharePolicy != rhs_storage._profilePictureSharePolicy {return false}
        if _storage._callPolicy != rhs_storage._callPolicy {return false}
        if _storage._setupWizardPolicy != rhs_storage._setupWizardPolicy {return false}
        if _storage._createGroupPolicy != rhs_storage._createGroupPolicy {return false}
        if _storage._shareMediaPolicy != rhs_storage._shareMediaPolicy {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_MdmParameters.ThreemaSafePolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SAFE_OPTIONAL"),
    1: .same(proto: "SAFE_MANDATORY"),
    2: .same(proto: "SAFE_DISABLED"),
  ]
}

extension Sync_MdmParameters.ThreemaSafeRestorePolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SAFE_RESTORE_OPTIONAL"),
    1: .same(proto: "SAFE_RESTORE_MANDATORY"),
    2: .same(proto: "SAFE_RESTORE_DISABLED"),
  ]
}

extension Sync_MdmParameters.OverridePolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LOOSE"),
    1: .same(proto: "STRICT"),
  ]
}

extension Sync_MdmParameters.ContactSyncPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOT_SYNCED"),
    1: .same(proto: "SYNC"),
  ]
}

extension Sync_MdmParameters.InactiveIdentityDisplayPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SHOW_INACTIVE"),
    1: .same(proto: "HIDE_INACTIVE"),
  ]
}

extension Sync_MdmParameters.UnknownContactPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_UNKNOWN"),
    1: .same(proto: "BLOCK_UNKNOWN"),
  ]
}

extension Sync_MdmParameters.AutoSaveMediaPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_AUTO_SAVE"),
    1: .same(proto: "DENY_AUTO_SAVE"),
  ]
}

extension Sync_MdmParameters.ScreenshotPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_SCREENSHOT"),
    1: .same(proto: "DENY_SCREENSHOT"),
  ]
}

extension Sync_MdmParameters.AddContactPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_ADD_CONTACT"),
    1: .same(proto: "DENY_ADD_CONTACT"),
  ]
}

extension Sync_MdmParameters.ChatExportPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_CHAT_EXPORT"),
    1: .same(proto: "DENY_CHAT_EXPORT"),
  ]
}

extension Sync_MdmParameters.BackupPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_BACKUP"),
    1: .same(proto: "DENY_BACKUP"),
  ]
}

extension Sync_MdmParameters.IdentityExportPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_IDENTITY_EXPORT"),
    1: .same(proto: "DENY_IDENTITY_EXPORT"),
  ]
}

extension Sync_MdmParameters.DataBackupPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_DATA_BACKUP"),
    1: .same(proto: "DENY_DATA_BACKUP"),
  ]
}

extension Sync_MdmParameters.SystemBackupPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_SYSTEM_BACKUP"),
    1: .same(proto: "DENY_SYSTEM_BACKUP"),
  ]
}

extension Sync_MdmParameters.MessagePreviewPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_PREVIEW"),
    1: .same(proto: "DENY_PREVIEW"),
  ]
}

extension Sync_MdmParameters.ProfilePictureSharePolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_SHARE"),
    1: .same(proto: "DENY_SHARE"),
  ]
}

extension Sync_MdmParameters.CallPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_CALL"),
    1: .same(proto: "DENY_CALL"),
  ]
}

extension Sync_MdmParameters.SetupWizardPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SHOW_WIZARD"),
    1: .same(proto: "SKIP_WIZARD"),
  ]
}

extension Sync_MdmParameters.CreateGroupPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_CREATE_GROUP"),
    1: .same(proto: "DENY_CREATE_GROUP"),
  ]
}

extension Sync_MdmParameters.ShareMediaPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_SHARE_MEDIA"),
    1: .same(proto: "DENY_OUTSIDE_APP"),
  ]
}

extension Sync_UserProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UserProfile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nickname"),
    2: .standard(proto: "profile_picture"),
    3: .standard(proto: "profile_picture_share_with"),
    4: .standard(proto: "identity_links"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._nickname) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._profilePicture) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._profilePictureShareWith) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._identityLinks) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._nickname {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._profilePicture {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._profilePictureShareWith {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._identityLinks {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sync_UserProfile, rhs: Sync_UserProfile) -> Bool {
    if lhs._nickname != rhs._nickname {return false}
    if lhs._profilePicture != rhs._profilePicture {return false}
    if lhs._profilePictureShareWith != rhs._profilePictureShareWith {return false}
    if lhs._identityLinks != rhs._identityLinks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_UserProfile.ProfilePictureShareWith: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sync_UserProfile.protoMessageName + ".ProfilePictureShareWith"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nobody"),
    2: .same(proto: "everyone"),
    3: .standard(proto: "allow_list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Common_Unit?
        var hadOneofValue = false
        if let current = self.policy {
          hadOneofValue = true
          if case .nobody(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.policy = .nobody(v)
        }
      }()
      case 2: try {
        var v: Common_Unit?
        var hadOneofValue = false
        if let current = self.policy {
          hadOneofValue = true
          if case .everyone(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.policy = .everyone(v)
        }
      }()
      case 3: try {
        var v: Common_Identities?
        var hadOneofValue = false
        if let current = self.policy {
          hadOneofValue = true
          if case .allowList(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.policy = .allowList(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.policy {
    case .nobody?: try {
      guard case .nobody(let v)? = self.policy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .everyone?: try {
      guard case .everyone(let v)? = self.policy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .allowList?: try {
      guard case .allowList(let v)? = self.policy else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sync_UserProfile.ProfilePictureShareWith, rhs: Sync_UserProfile.ProfilePictureShareWith) -> Bool {
    if lhs.policy != rhs.policy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_UserProfile.IdentityLinks: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sync_UserProfile.protoMessageName + ".IdentityLinks"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "links"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.links) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.links.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.links, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sync_UserProfile.IdentityLinks, rhs: Sync_UserProfile.IdentityLinks) -> Bool {
    if lhs.links != rhs.links {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_UserProfile.IdentityLinks.IdentityLink: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sync_UserProfile.IdentityLinks.protoMessageName + ".IdentityLink"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "phone_number"),
    2: .same(proto: "email"),
    3: .same(proto: "description"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.type != nil {try decoder.handleConflictingOneOf()}
          self.type = .phoneNumber(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.type != nil {try decoder.handleConflictingOneOf()}
          self.type = .email(v)
        }
      }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.type {
    case .phoneNumber?: try {
      guard case .phoneNumber(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }()
    case .email?: try {
      guard case .email(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sync_UserProfile.IdentityLinks.IdentityLink, rhs: Sync_UserProfile.IdentityLinks.IdentityLink) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Contact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Contact"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "identity"),
    2: .standard(proto: "public_key"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "first_name"),
    5: .standard(proto: "last_name"),
    6: .same(proto: "nickname"),
    7: .standard(proto: "verification_level"),
    21: .standard(proto: "work_verification_level"),
    8: .standard(proto: "identity_type"),
    9: .standard(proto: "acquaintance_level"),
    10: .standard(proto: "activity_state"),
    18: .standard(proto: "feature_mask"),
    13: .standard(proto: "sync_state"),
    16: .standard(proto: "read_receipt_policy_override"),
    17: .standard(proto: "typing_indicator_policy_override"),
    19: .standard(proto: "notification_trigger_policy_override"),
    20: .standard(proto: "notification_sound_policy_override"),
    14: .standard(proto: "contact_defined_profile_picture"),
    15: .standard(proto: "user_defined_profile_picture"),
    11: .standard(proto: "conversation_category"),
    12: .standard(proto: "conversation_visibility"),
  ]

  fileprivate class _StorageClass {
    var _identity: String = String()
    var _publicKey: Data? = nil
    var _createdAt: UInt64? = nil
    var _firstName: String? = nil
    var _lastName: String? = nil
    var _nickname: String? = nil
    var _verificationLevel: Sync_Contact.VerificationLevel? = nil
    var _workVerificationLevel: Sync_Contact.WorkVerificationLevel? = nil
    var _identityType: Sync_Contact.IdentityType? = nil
    var _acquaintanceLevel: Sync_Contact.AcquaintanceLevel? = nil
    var _activityState: Sync_Contact.ActivityState? = nil
    var _featureMask: UInt32? = nil
    var _syncState: Sync_Contact.SyncState? = nil
    var _readReceiptPolicyOverride: Sync_Contact.ReadReceiptPolicyOverride? = nil
    var _typingIndicatorPolicyOverride: Sync_Contact.TypingIndicatorPolicyOverride? = nil
    var _notificationTriggerPolicyOverride: Sync_Contact.NotificationTriggerPolicyOverride? = nil
    var _notificationSoundPolicyOverride: Sync_Contact.NotificationSoundPolicyOverride? = nil
    var _contactDefinedProfilePicture: Common_DeltaImage? = nil
    var _userDefinedProfilePicture: Common_DeltaImage? = nil
    var _conversationCategory: Sync_ConversationCategory? = nil
    var _conversationVisibility: Sync_ConversationVisibility? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _identity = source._identity
      _publicKey = source._publicKey
      _createdAt = source._createdAt
      _firstName = source._firstName
      _lastName = source._lastName
      _nickname = source._nickname
      _verificationLevel = source._verificationLevel
      _workVerificationLevel = source._workVerificationLevel
      _identityType = source._identityType
      _acquaintanceLevel = source._acquaintanceLevel
      _activityState = source._activityState
      _featureMask = source._featureMask
      _syncState = source._syncState
      _readReceiptPolicyOverride = source._readReceiptPolicyOverride
      _typingIndicatorPolicyOverride = source._typingIndicatorPolicyOverride
      _notificationTriggerPolicyOverride = source._notificationTriggerPolicyOverride
      _notificationSoundPolicyOverride = source._notificationSoundPolicyOverride
      _contactDefinedProfilePicture = source._contactDefinedProfilePicture
      _userDefinedProfilePicture = source._userDefinedProfilePicture
      _conversationCategory = source._conversationCategory
      _conversationVisibility = source._conversationVisibility
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._identity) }()
        case 2: try { try decoder.decodeSingularBytesField(value: &_storage._publicKey) }()
        case 3: try { try decoder.decodeSingularUInt64Field(value: &_storage._createdAt) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._firstName) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._lastName) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._nickname) }()
        case 7: try { try decoder.decodeSingularEnumField(value: &_storage._verificationLevel) }()
        case 8: try { try decoder.decodeSingularEnumField(value: &_storage._identityType) }()
        case 9: try { try decoder.decodeSingularEnumField(value: &_storage._acquaintanceLevel) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._activityState) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._conversationCategory) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._conversationVisibility) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._syncState) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._contactDefinedProfilePicture) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._userDefinedProfilePicture) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._readReceiptPolicyOverride) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._typingIndicatorPolicyOverride) }()
        case 18: try { try decoder.decodeSingularUInt32Field(value: &_storage._featureMask) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._notificationTriggerPolicyOverride) }()
        case 20: try { try decoder.decodeSingularMessageField(value: &_storage._notificationSoundPolicyOverride) }()
        case 21: try { try decoder.decodeSingularEnumField(value: &_storage._workVerificationLevel) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._identity.isEmpty {
        try visitor.visitSingularStringField(value: _storage._identity, fieldNumber: 1)
      }
      if let v = _storage._publicKey {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
      }
      if let v = _storage._createdAt {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
      }
      if let v = _storage._firstName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 4)
      }
      if let v = _storage._lastName {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      }
      if let v = _storage._nickname {
        try visitor.visitSingularStringField(value: v, fieldNumber: 6)
      }
      if let v = _storage._verificationLevel {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
      }
      if let v = _storage._identityType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 8)
      }
      if let v = _storage._acquaintanceLevel {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 9)
      }
      if let v = _storage._activityState {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 10)
      }
      if let v = _storage._conversationCategory {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 11)
      }
      if let v = _storage._conversationVisibility {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 12)
      }
      if let v = _storage._syncState {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 13)
      }
      if let v = _storage._contactDefinedProfilePicture {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }
      if let v = _storage._userDefinedProfilePicture {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }
      if let v = _storage._readReceiptPolicyOverride {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }
      if let v = _storage._typingIndicatorPolicyOverride {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }
      if let v = _storage._featureMask {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 18)
      }
      if let v = _storage._notificationTriggerPolicyOverride {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }
      if let v = _storage._notificationSoundPolicyOverride {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }
      if let v = _storage._workVerificationLevel {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sync_Contact, rhs: Sync_Contact) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._identity != rhs_storage._identity {return false}
        if _storage._publicKey != rhs_storage._publicKey {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._firstName != rhs_storage._firstName {return false}
        if _storage._lastName != rhs_storage._lastName {return false}
        if _storage._nickname != rhs_storage._nickname {return false}
        if _storage._verificationLevel != rhs_storage._verificationLevel {return false}
        if _storage._workVerificationLevel != rhs_storage._workVerificationLevel {return false}
        if _storage._identityType != rhs_storage._identityType {return false}
        if _storage._acquaintanceLevel != rhs_storage._acquaintanceLevel {return false}
        if _storage._activityState != rhs_storage._activityState {return false}
        if _storage._featureMask != rhs_storage._featureMask {return false}
        if _storage._syncState != rhs_storage._syncState {return false}
        if _storage._readReceiptPolicyOverride != rhs_storage._readReceiptPolicyOverride {return false}
        if _storage._typingIndicatorPolicyOverride != rhs_storage._typingIndicatorPolicyOverride {return false}
        if _storage._notificationTriggerPolicyOverride != rhs_storage._notificationTriggerPolicyOverride {return false}
        if _storage._notificationSoundPolicyOverride != rhs_storage._notificationSoundPolicyOverride {return false}
        if _storage._contactDefinedProfilePicture != rhs_storage._contactDefinedProfilePicture {return false}
        if _storage._userDefinedProfilePicture != rhs_storage._userDefinedProfilePicture {return false}
        if _storage._conversationCategory != rhs_storage._conversationCategory {return false}
        if _storage._conversationVisibility != rhs_storage._conversationVisibility {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Contact.VerificationLevel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNVERIFIED"),
    1: .same(proto: "SERVER_VERIFIED"),
    2: .same(proto: "FULLY_VERIFIED"),
  ]
}

extension Sync_Contact.WorkVerificationLevel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "WORK_SUBSCRIPTION_VERIFIED"),
  ]
}

extension Sync_Contact.IdentityType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REGULAR"),
    1: .same(proto: "WORK"),
  ]
}

extension Sync_Contact.AcquaintanceLevel: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DIRECT"),
    1: .same(proto: "GROUP"),
  ]
}

extension Sync_Contact.ActivityState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACTIVE"),
    1: .same(proto: "INACTIVE"),
    2: .same(proto: "INVALID"),
  ]
}

extension Sync_Contact.SyncState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INITIAL"),
    1: .same(proto: "IMPORTED"),
    2: .same(proto: "CUSTOM"),
  ]
}

extension Sync_Contact.ReadReceiptPolicyOverride: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sync_Contact.protoMessageName + ".ReadReceiptPolicyOverride"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "default"),
    2: .same(proto: "policy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Common_Unit?
        var hadOneofValue = false
        if let current = self.override {
          hadOneofValue = true
          if case .default(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.override = .default(v)
        }
      }()
      case 2: try {
        var v: Sync_ReadReceiptPolicy?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.override != nil {try decoder.handleConflictingOneOf()}
          self.override = .policy(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.override {
    case .default?: try {
      guard case .default(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .policy?: try {
      guard case .policy(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sync_Contact.ReadReceiptPolicyOverride, rhs: Sync_Contact.ReadReceiptPolicyOverride) -> Bool {
    if lhs.override != rhs.override {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Contact.TypingIndicatorPolicyOverride: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sync_Contact.protoMessageName + ".TypingIndicatorPolicyOverride"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "default"),
    2: .same(proto: "policy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Common_Unit?
        var hadOneofValue = false
        if let current = self.override {
          hadOneofValue = true
          if case .default(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.override = .default(v)
        }
      }()
      case 2: try {
        var v: Sync_TypingIndicatorPolicy?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.override != nil {try decoder.handleConflictingOneOf()}
          self.override = .policy(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.override {
    case .default?: try {
      guard case .default(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .policy?: try {
      guard case .policy(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sync_Contact.TypingIndicatorPolicyOverride, rhs: Sync_Contact.TypingIndicatorPolicyOverride) -> Bool {
    if lhs.override != rhs.override {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Contact.NotificationTriggerPolicyOverride: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sync_Contact.protoMessageName + ".NotificationTriggerPolicyOverride"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "default"),
    2: .same(proto: "policy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Common_Unit?
        var hadOneofValue = false
        if let current = self.override {
          hadOneofValue = true
          if case .default(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.override = .default(v)
        }
      }()
      case 2: try {
        var v: Sync_Contact.NotificationTriggerPolicyOverride.Policy?
        var hadOneofValue = false
        if let current = self.override {
          hadOneofValue = true
          if case .policy(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.override = .policy(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.override {
    case .default?: try {
      guard case .default(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .policy?: try {
      guard case .policy(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sync_Contact.NotificationTriggerPolicyOverride, rhs: Sync_Contact.NotificationTriggerPolicyOverride) -> Bool {
    if lhs.override != rhs.override {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Contact.NotificationTriggerPolicyOverride.Policy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sync_Contact.NotificationTriggerPolicyOverride.protoMessageName + ".Policy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "policy"),
    2: .standard(proto: "expires_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.policy) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._expiresAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.policy != .never {
      try visitor.visitSingularEnumField(value: self.policy, fieldNumber: 1)
    }
    if let v = self._expiresAt {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sync_Contact.NotificationTriggerPolicyOverride.Policy, rhs: Sync_Contact.NotificationTriggerPolicyOverride.Policy) -> Bool {
    if lhs.policy != rhs.policy {return false}
    if lhs._expiresAt != rhs._expiresAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Contact.NotificationTriggerPolicyOverride.Policy.NotificationTriggerPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NEVER"),
  ]
}

extension Sync_Contact.NotificationSoundPolicyOverride: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sync_Contact.protoMessageName + ".NotificationSoundPolicyOverride"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "default"),
    2: .same(proto: "policy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Common_Unit?
        var hadOneofValue = false
        if let current = self.override {
          hadOneofValue = true
          if case .default(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.override = .default(v)
        }
      }()
      case 2: try {
        var v: Sync_NotificationSoundPolicy?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.override != nil {try decoder.handleConflictingOneOf()}
          self.override = .policy(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.override {
    case .default?: try {
      guard case .default(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .policy?: try {
      guard case .policy(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sync_Contact.NotificationSoundPolicyOverride, rhs: Sync_Contact.NotificationSoundPolicyOverride) -> Bool {
    if lhs.override != rhs.override {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Group: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Group"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_identity"),
    2: .same(proto: "name"),
    3: .standard(proto: "created_at"),
    6: .standard(proto: "user_state"),
    9: .standard(proto: "notification_trigger_policy_override"),
    10: .standard(proto: "notification_sound_policy_override"),
    7: .standard(proto: "profile_picture"),
    8: .standard(proto: "member_identities"),
    4: .standard(proto: "conversation_category"),
    5: .standard(proto: "conversation_visibility"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._groupIdentity) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._createdAt) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._conversationCategory) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._conversationVisibility) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._userState) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._profilePicture) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._memberIdentities) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._notificationTriggerPolicyOverride) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._notificationSoundPolicyOverride) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._groupIdentity {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._createdAt {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }
    if let v = self._conversationCategory {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    }
    if let v = self._conversationVisibility {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    }
    if let v = self._userState {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    }
    if let v = self._profilePicture {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._memberIdentities {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if let v = self._notificationTriggerPolicyOverride {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if let v = self._notificationSoundPolicyOverride {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sync_Group, rhs: Sync_Group) -> Bool {
    if lhs._groupIdentity != rhs._groupIdentity {return false}
    if lhs._name != rhs._name {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._userState != rhs._userState {return false}
    if lhs._notificationTriggerPolicyOverride != rhs._notificationTriggerPolicyOverride {return false}
    if lhs._notificationSoundPolicyOverride != rhs._notificationSoundPolicyOverride {return false}
    if lhs._profilePicture != rhs._profilePicture {return false}
    if lhs._memberIdentities != rhs._memberIdentities {return false}
    if lhs._conversationCategory != rhs._conversationCategory {return false}
    if lhs._conversationVisibility != rhs._conversationVisibility {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Group.UserState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MEMBER"),
    1: .same(proto: "KICKED"),
    2: .same(proto: "LEFT"),
  ]
}

extension Sync_Group.NotificationTriggerPolicyOverride: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sync_Group.protoMessageName + ".NotificationTriggerPolicyOverride"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "default"),
    2: .same(proto: "policy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Common_Unit?
        var hadOneofValue = false
        if let current = self.override {
          hadOneofValue = true
          if case .default(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.override = .default(v)
        }
      }()
      case 2: try {
        var v: Sync_Group.NotificationTriggerPolicyOverride.Policy?
        var hadOneofValue = false
        if let current = self.override {
          hadOneofValue = true
          if case .policy(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.override = .policy(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.override {
    case .default?: try {
      guard case .default(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .policy?: try {
      guard case .policy(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sync_Group.NotificationTriggerPolicyOverride, rhs: Sync_Group.NotificationTriggerPolicyOverride) -> Bool {
    if lhs.override != rhs.override {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Group.NotificationTriggerPolicyOverride.Policy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sync_Group.NotificationTriggerPolicyOverride.protoMessageName + ".Policy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "policy"),
    2: .standard(proto: "expires_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.policy) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._expiresAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.policy != .mentioned {
      try visitor.visitSingularEnumField(value: self.policy, fieldNumber: 1)
    }
    if let v = self._expiresAt {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sync_Group.NotificationTriggerPolicyOverride.Policy, rhs: Sync_Group.NotificationTriggerPolicyOverride.Policy) -> Bool {
    if lhs.policy != rhs.policy {return false}
    if lhs._expiresAt != rhs._expiresAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Group.NotificationTriggerPolicyOverride.Policy.NotificationTriggerPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MENTIONED"),
    1: .same(proto: "NEVER"),
  ]
}

extension Sync_Group.NotificationSoundPolicyOverride: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Sync_Group.protoMessageName + ".NotificationSoundPolicyOverride"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "default"),
    2: .same(proto: "policy"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Common_Unit?
        var hadOneofValue = false
        if let current = self.override {
          hadOneofValue = true
          if case .default(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.override = .default(v)
        }
      }()
      case 2: try {
        var v: Sync_NotificationSoundPolicy?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.override != nil {try decoder.handleConflictingOneOf()}
          self.override = .policy(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.override {
    case .default?: try {
      guard case .default(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .policy?: try {
      guard case .policy(let v)? = self.override else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sync_Group.NotificationSoundPolicyOverride, rhs: Sync_Group.NotificationSoundPolicyOverride) -> Bool {
    if lhs.override != rhs.override {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_DistributionList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DistributionList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "distribution_list_id"),
    2: .same(proto: "name"),
    3: .standard(proto: "created_at"),
    6: .standard(proto: "member_identities"),
    4: .standard(proto: "conversation_category"),
    5: .standard(proto: "conversation_visibility"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.distributionListID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self._createdAt) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._conversationCategory) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._conversationVisibility) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._memberIdentities) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.distributionListID != 0 {
      try visitor.visitSingularFixed64Field(value: self.distributionListID, fieldNumber: 1)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._createdAt {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 3)
    }
    if let v = self._conversationCategory {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    }
    if let v = self._conversationVisibility {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    }
    if let v = self._memberIdentities {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sync_DistributionList, rhs: Sync_DistributionList) -> Bool {
    if lhs.distributionListID != rhs.distributionListID {return false}
    if lhs._name != rhs._name {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._memberIdentities != rhs._memberIdentities {return false}
    if lhs._conversationCategory != rhs._conversationCategory {return false}
    if lhs._conversationVisibility != rhs._conversationVisibility {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Settings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Settings"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "contact_sync_policy"),
    2: .standard(proto: "unknown_contact_policy"),
    3: .standard(proto: "read_receipt_policy"),
    4: .standard(proto: "typing_indicator_policy"),
    5: .standard(proto: "call_policy"),
    6: .standard(proto: "call_connection_polity"),
    7: .standard(proto: "screenshot_policy"),
    8: .standard(proto: "keyboard_data_collection_policy"),
    9: .standard(proto: "blocked_identities"),
    10: .standard(proto: "exclude_from_sync_identities"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._contactSyncPolicy) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._unknownContactPolicy) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._readReceiptPolicy) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._typingIndicatorPolicy) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._callPolicy) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._callConnectionPolity) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self._screenshotPolicy) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self._keyboardDataCollectionPolicy) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._blockedIdentities) }()
      case 10: try { try decoder.decodeSingularMessageField(value: &self._excludeFromSyncIdentities) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._contactSyncPolicy {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._unknownContactPolicy {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }
    if let v = self._readReceiptPolicy {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }
    if let v = self._typingIndicatorPolicy {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    }
    if let v = self._callPolicy {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    }
    if let v = self._callConnectionPolity {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    }
    if let v = self._screenshotPolicy {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    }
    if let v = self._keyboardDataCollectionPolicy {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 8)
    }
    if let v = self._blockedIdentities {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if let v = self._excludeFromSyncIdentities {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Sync_Settings, rhs: Sync_Settings) -> Bool {
    if lhs._contactSyncPolicy != rhs._contactSyncPolicy {return false}
    if lhs._unknownContactPolicy != rhs._unknownContactPolicy {return false}
    if lhs._readReceiptPolicy != rhs._readReceiptPolicy {return false}
    if lhs._typingIndicatorPolicy != rhs._typingIndicatorPolicy {return false}
    if lhs._callPolicy != rhs._callPolicy {return false}
    if lhs._callConnectionPolity != rhs._callConnectionPolity {return false}
    if lhs._screenshotPolicy != rhs._screenshotPolicy {return false}
    if lhs._keyboardDataCollectionPolicy != rhs._keyboardDataCollectionPolicy {return false}
    if lhs._blockedIdentities != rhs._blockedIdentities {return false}
    if lhs._excludeFromSyncIdentities != rhs._excludeFromSyncIdentities {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Sync_Settings.ContactSyncPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOT_SYNCED"),
    1: .same(proto: "SYNC"),
  ]
}

extension Sync_Settings.UnknownContactPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_UNKNOWN"),
    1: .same(proto: "BLOCK_UNKNOWN"),
  ]
}

extension Sync_Settings.CallPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_CALL"),
    1: .same(proto: "DENY_CALL"),
  ]
}

extension Sync_Settings.CallConnectionPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_DIRECT"),
    1: .same(proto: "REQUIRE_RELAY"),
  ]
}

extension Sync_Settings.ScreenshotPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_SCREENSHOT"),
    1: .same(proto: "DENY_SCREENSHOT"),
  ]
}

extension Sync_Settings.KeyboardDataCollectionPolicy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ALLOW_DATA_COLLECTION"),
    1: .same(proto: "DENY_DATA_COLLECTION"),
  ]
}
